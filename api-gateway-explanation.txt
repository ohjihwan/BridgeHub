# API Gateway 도입 가이드

## 1. 현재 구조의 문제점
```
[클라이언트] → [서버1] → [서버2] → [서버3]
    ↑            ↑          ↑          ↑
    └────────────┴──────────┴──────────┘
        각각의 서버마다 인증 처리 필요
```

현재 구조의 문제점:
- 각 서버마다 인증 로직 중복 구현
- 서버 간 통신 시 인증 토큰 재검증 필요
- 클라이언트가 여러 서버의 엔드포인트 관리 필요
- 보안 정책 일관성 유지 어려움

## 2. API Gateway 도입 후 구조
```
[클라이언트] → [API Gateway] → [서버1]
                          → [서버2]
                          → [서버3]
                          → [WebRTC 서버]
```

## 3. API Gateway의 주요 이점

### 3.1 인증/인가 통합 관리
- 단일 인증 지점 제공
- JWT 토큰 검증 중앙화
- 세션 관리 일원화
- 권한 기반 접근 제어 (RBAC) 구현 용이

### 3.2 라우팅 및 로드 밸런싱
- 서비스별 엔드포인트 통합 관리
- 요청 분배 및 부하 분산
- 서비스 디스커버리 지원
- 장애 서비스 자동 감지 및 우회

### 3.3 보안 강화
- DDoS 방어
- Rate Limiting
- IP 화이트리스트/블랙리스트
- SSL/TLS 종단점

### 3.4 모니터링 및 로깅
- 중앙화된 로그 수집
- 서비스 상태 모니터링
- 성능 메트릭 수집
- 문제 발생 시 빠른 대응

## 4. WebRTC 서버 통합 시 이점

### 4.1 인증 흐름
```
[클라이언트] → [API Gateway] → [인증 서버]
    ↓
[WebRTC 서버] ← [API Gateway] ← [인증 토큰 검증]
```

### 4.2 WebRTC 특화 기능
- 시그널링 서버 통합
- STUN/TURN 서버 관리
- 미디어 서버 라우팅
- 실시간 통신 보안

## 5. 구현 가이드

### 5.1 API Gateway 선택
추천 옵션:
1. Kong Gateway
   - 오픈소스
   - 플러그인 기반 확장
   - 높은 성능

2. Express Gateway
   - Node.js 기반
   - 쉬운 설정
   - 빠른 개발

3. AWS API Gateway
   - 완전 관리형
   - 높은 확장성
   - 다양한 통합

### 5.2 기본 설정 예시 (Express Gateway)
```javascript
// gateway.config.yml
http:
  port: 8080
admin:
  port: 9876
apiEndpoints:
  auth:
    host: localhost
    paths: /auth/*
  study:
    host: localhost
    paths: /study/*
  chat:
    host: localhost
    paths: /chat/*
  webrtc:
    host: localhost
    paths: /webrtc/*

pipelines:
  authPipeline:
    apiEndpoints:
      - auth
    policies:
      - jwt:
          secretOrPublicKey: 'your-secret-key'
      - proxy:
          action:
            serviceEndpoint: authService
            changeOrigin: true

  studyPipeline:
    apiEndpoints:
      - study
    policies:
      - jwt:
          secretOrPublicKey: 'your-secret-key'
      - proxy:
          action:
            serviceEndpoint: studyService
            changeOrigin: true
```

### 5.3 서비스 등록
```javascript
services:
  authService:
    url: 'http://localhost:3001'
  studyService:
    url: 'http://localhost:3002'
  chatService:
    url: 'http://localhost:3003'
  webrtcService:
    url: 'http://localhost:3004'
```

## 6. 보안 설정

### 6.1 JWT 인증
```javascript
// JWT 미들웨어 설정
const jwt = require('jsonwebtoken');

const verifyToken = (req, res, next) => {
  const token = req.headers['authorization'];
  
  if (!token) {
    return res.status(403).send('토큰이 필요합니다');
  }

  try {
    const decoded = jwt.verify(token, 'your-secret-key');
    req.user = decoded;
    next();
  } catch (err) {
    return res.status(401).send('유효하지 않은 토큰');
  }
};
```

### 6.2 Rate Limiting
```javascript
// Rate Limiting 설정
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15분
  max: 100 // IP당 최대 요청 수
});

app.use(limiter);
```

## 7. 모니터링 설정

### 7.1 로깅
```javascript
// Winston 로거 설정
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});
```

### 7.2 메트릭 수집
```javascript
// Prometheus 메트릭 설정
const prometheus = require('prom-client');

const httpRequestDuration = new prometheus.Histogram({
  name: 'http_request_duration_seconds',
  help: 'HTTP 요청 처리 시간',
  labelNames: ['method', 'route', 'status_code']
});
```

## 8. 배포 전략

### 8.1 단계적 배포
1. 개발 환경 테스트
2. 스테이징 환경 검증
3. 프로덕션 환경 점진적 적용

### 8.2 롤백 계획
- 이전 버전 백업
- 롤백 스크립트 준비
- 모니터링 지표 설정

## 9. 유지보수 가이드

### 9.1 정기 점검 항목
- 로그 분석
- 성능 메트릭 확인
- 보안 취약점 검사
- 인증 토큰 만료 관리

### 9.2 문제 해결 절차
1. 로그 확인
2. 메트릭 분석
3. 서비스 상태 점검
4. 롤백 결정

## 10. 결론

API Gateway 도입을 통해:
- 인증/인가 통합 관리
- 서비스 간 통신 단순화
- 보안 강화
- 모니터링 용이성
- WebRTC 서버 통합 용이

이러한 이점들을 얻을 수 있으며, 특히 WebRTC 서버 추가 시 인증 관리가 더욱 효율적으로 이루어질 수 있습니다. 

## 11. WebRTC 서버 인증 구현 전략

### 11.1 WebRTC 인증 흐름
```
[클라이언트] → [API Gateway] → [인증 서버]
    ↓
[WebRTC 서버] ← [API Gateway] ← [인증 토큰 검증]
    ↓
[STUN/TURN 서버] ← [인증된 클라이언트]
```

### 11.2 WebRTC 인증 단계

1. 초기 연결 인증
```javascript
// WebRTC 연결 요청 시
const webrtcAuth = {
  token: 'jwt-token',
  roomId: 'study-room-123',
  userId: 'user-456',
  permissions: ['audio', 'video', 'screen']
};
```

2. 시그널링 서버 인증
```javascript
// 시그널링 서버 연결 시
socket.on('connect', () => {
  socket.emit('authenticate', {
    token: webrtcAuth.token,
    roomId: webrtcAuth.roomId
  });
});
```

3. STUN/TURN 서버 인증
```javascript
// TURN 서버 인증 정보
const turnConfig = {
  urls: 'turn:your-turn-server.com',
  username: 'username',
  credential: 'credential',
  credentialType: 'token'
};
```

### 11.3 API Gateway를 통한 WebRTC 인증 구현

#### 11.3.1 Gateway 설정
```javascript
// gateway.config.yml
apiEndpoints:
  webrtc:
    host: localhost
    paths: /webrtc/*
    methods: ['GET', 'POST', 'PUT', 'DELETE']

pipelines:
  webrtcPipeline:
    apiEndpoints:
      - webrtc
    policies:
      - jwt:
          secretOrPublicKey: 'your-secret-key'
      - rateLimit:
          max: 100
          windowMs: 60000
      - proxy:
          action:
            serviceEndpoint: webrtcService
            changeOrigin: true
```

#### 11.3.2 WebRTC 서비스 등록
```javascript
services:
  webrtcService:
    url: 'http://localhost:3004'
    endpoints:
      - /signaling
      - /turn
      - /rooms
```

### 11.4 보안 전략

#### 11.4.1 토큰 기반 인증
```javascript
// JWT 토큰 생성
const generateWebRTCToken = (userId, roomId, permissions) => {
  return jwt.sign({
    userId,
    roomId,
    permissions,
    type: 'webrtc',
    exp: Math.floor(Date.now() / 1000) + (60 * 60) // 1시간
  }, 'your-secret-key');
};

// 토큰 검증 미들웨어
const verifyWebRTCToken = (req, res, next) => {
  const token = req.headers['authorization'];
  
  try {
    const decoded = jwt.verify(token, 'your-secret-key');
    if (decoded.type !== 'webrtc') {
      throw new Error('Invalid token type');
    }
    req.user = decoded;
    next();
  } catch (err) {
    res.status(401).json({ error: 'Invalid token' });
  }
};
```

#### 11.4.2 방 접근 제어
```javascript
// 방 접근 권한 검증
const verifyRoomAccess = async (userId, roomId) => {
  const room = await Room.findById(roomId);
  if (!room) return false;
  
  return room.participants.includes(userId) || 
         room.owner === userId;
};
```

### 11.5 실시간 통신 보안

#### 11.5.1 시그널링 보안
```javascript
// 시그널링 메시지 암호화
const encryptSignalingMessage = (message) => {
  return crypto.createCipheriv(
    'aes-256-gcm',
    process.env.SIGNALING_KEY,
    iv
  ).update(JSON.stringify(message));
};

// 시그널링 메시지 복호화
const decryptSignalingMessage = (encryptedMessage) => {
  return crypto.createDecipheriv(
    'aes-256-gcm',
    process.env.SIGNALING_KEY,
    iv
  ).update(encryptedMessage);
};
```

#### 11.5.2 미디어 스트림 보안
```javascript
// DTLS-SRTP 설정
const dtlsConfig = {
  srtpProtectionProfiles: [
    'SRTP_AES128_CM_HMAC_SHA1_80',
    'SRTP_AES128_CM_HMAC_SHA1_32'
  ],
  srtpMasterKey: crypto.randomBytes(16),
  srtpMasterSalt: crypto.randomBytes(14)
};
```

### 11.6 모니터링 및 로깅

#### 11.6.1 WebRTC 메트릭 수집
```javascript
// WebRTC 성능 메트릭
const webrtcMetrics = {
  connectionQuality: new prometheus.Gauge({
    name: 'webrtc_connection_quality',
    help: 'WebRTC 연결 품질',
    labelNames: ['roomId', 'userId']
  }),
  
  mediaStats: new prometheus.Histogram({
    name: 'webrtc_media_stats',
    help: 'WebRTC 미디어 통계',
    labelNames: ['roomId', 'userId', 'type']
  })
};
```

#### 11.6.2 보안 이벤트 로깅
```javascript
// 보안 이벤트 로거
const securityLogger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ 
      filename: 'webrtc-security.log',
      level: 'warn'
    })
  ]
});

// 보안 이벤트 기록
const logSecurityEvent = (event) => {
  securityLogger.warn({
    timestamp: new Date(),
    event: event.type,
    userId: event.userId,
    roomId: event.roomId,
    details: event.details
  });
};
```

### 11.7 구현 전략

1. 단계적 구현
   - 기본 인증 구현
   - 시그널링 서버 통합
   - STUN/TURN 서버 설정
   - 보안 기능 추가

2. 테스트 계획
   - 단위 테스트
   - 통합 테스트
   - 부하 테스트
   - 보안 테스트

3. 배포 전략
   - 개발 환경 테스트
   - 스테이징 환경 검증
   - 프로덕션 환경 점진적 적용

4. 모니터링 계획
   - 성능 메트릭 수집
   - 보안 이벤트 모니터링
   - 사용자 피드백 수집

이러한 구현 전략을 통해 안전하고 효율적인 WebRTC 서비스를 제공할 수 있습니다. 

## 12. CoTURN 서버와 API Gateway 연동

### 12.1 CoTURN 서버 구조
```
[클라이언트] → [API Gateway] → [CoTURN 서버]
    ↓              ↓              ↓
[인증 토큰]    [토큰 검증]    [TURN 인증]
    ↓              ↓              ↓
[WebRTC 연결] ← [인증 응답] ← [TURN 자격 증명]
```

### 12.2 CoTURN 서버 설정

#### 12.2.1 CoTURN 기본 설정
```bash
# turnserver.conf
listening-port=3478
tls-listening-port=5349
listening-ip=0.0.0.0
external-ip=YOUR_PUBLIC_IP
min-port=49152
max-port=65535
user=username:password
realm=your-domain.com
total-quota=100
stale-nonce=600
cert=/path/to/cert.pem
pkey=/path/to/private.pem
```

#### 12.2.2 API Gateway를 통한 TURN 인증 설정
```javascript
// gateway.config.yml
apiEndpoints:
  turn:
    host: localhost
    paths: /turn/*
    methods: ['GET', 'POST']

pipelines:
  turnPipeline:
    apiEndpoints:
      - turn
    policies:
      - jwt:
          secretOrPublicKey: 'your-secret-key'
      - rateLimit:
          max: 50
          windowMs: 60000
      - proxy:
          action:
            serviceEndpoint: turnService
            changeOrigin: true

services:
  turnService:
    url: 'http://localhost:3478'
    endpoints:
      - /turn/credentials
      - /turn/validate
```

### 12.3 TURN 인증 구현

#### 12.3.1 TURN 자격 증명 생성
```javascript
// TURN 자격 증명 생성 미들웨어
const generateTURNCredentials = async (req, res) => {
  const { userId, roomId } = req.user;
  
  // TURN 서버 인증 정보 생성
  const turnConfig = {
    urls: [
      'turn:your-turn-server.com:3478',
      'turns:your-turn-server.com:5349'
    ],
    username: `${userId}:${roomId}:${Date.now()}`,
    credential: generateTURNCredential(userId, roomId),
    credentialType: 'token'
  };

  // Redis에 TURN 세션 저장
  await redis.set(
    `turn:${userId}:${roomId}`,
    JSON.stringify(turnConfig),
    'EX',
    3600 // 1시간
  );

  res.json(turnConfig);
};

// TURN 자격 증명 생성 함수
const generateTURNCredential = (userId, roomId) => {
  const hmac = crypto.createHmac('sha1', process.env.TURN_SECRET);
  hmac.update(`${userId}:${roomId}:${Date.now()}`);
  return hmac.digest('base64');
};
```

#### 12.3.2 TURN 인증 검증
```javascript
// TURN 인증 검증 미들웨어
const verifyTURNAuth = async (req, res, next) => {
  const { username, credential } = req.headers;
  
  try {
    const [userId, roomId, timestamp] = username.split(':');
    
    // Redis에서 TURN 세션 확인
    const session = await redis.get(`turn:${userId}:${roomId}`);
    if (!session) {
      throw new Error('Invalid TURN session');
    }

    const turnConfig = JSON.parse(session);
    if (turnConfig.credential !== credential) {
      throw new Error('Invalid TURN credentials');
    }

    // 타임스탬프 검증 (1시간 이내)
    const sessionTime = parseInt(timestamp);
    if (Date.now() - sessionTime > 3600000) {
      throw new Error('TURN session expired');
    }

    req.turnSession = turnConfig;
    next();
  } catch (err) {
    res.status(401).json({ error: 'Invalid TURN authentication' });
  }
};
```

### 12.4 클라이언트 측 구현

#### 12.4.1 TURN 서버 연결
```javascript
// WebRTC 클라이언트 설정
const getTURNConfig = async () => {
  const response = await fetch('/api/turn/credentials', {
    headers: {
      'Authorization': `Bearer ${jwtToken}`
    }
  });
  
  const turnConfig = await response.json();
  
  return {
    iceServers: [
      {
        urls: turnConfig.urls,
        username: turnConfig.username,
        credential: turnConfig.credential,
        credentialType: turnConfig.credentialType
      }
    ]
  };
};

// WebRTC 피어 연결 설정
const peerConnection = new RTCPeerConnection(getTURNConfig());
```

### 12.5 보안 강화

#### 12.5.1 TURN 서버 보안 설정
```javascript
// TURN 서버 보안 정책
const turnSecurityPolicy = {
  // IP 기반 접근 제어
  allowedIPs: [
    '192.168.1.0/24',
    '10.0.0.0/8'
  ],
  
  // 세션 제한
  maxSessionsPerUser: 5,
  sessionTimeout: 3600,
  
  // 대역폭 제한
  bandwidthLimit: {
    audio: 100000,  // 100kbps
    video: 1000000  // 1Mbps
  }
};
```

#### 12.5.2 모니터링 및 로깅
```javascript
// TURN 서버 모니터링
const turnMetrics = {
  activeConnections: new prometheus.Gauge({
    name: 'turn_active_connections',
    help: '활성 TURN 연결 수',
    labelNames: ['protocol']
  }),
  
  bandwidthUsage: new prometheus.Histogram({
    name: 'turn_bandwidth_usage',
    help: 'TURN 서버 대역폭 사용량',
    labelNames: ['type']
  }),
  
  authenticationFailures: new prometheus.Counter({
    name: 'turn_auth_failures',
    help: 'TURN 인증 실패 횟수',
    labelNames: ['reason']
  })
};

// TURN 서버 로깅
const turnLogger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ 
      filename: 'turn-server.log',
      level: 'info'
    })
  ]
});
```

### 12.6 구현 전략

1. CoTURN 서버 설정
   - 기본 설정 구성
   - SSL/TLS 인증서 설정
   - 방화벽 규칙 설정

2. API Gateway 통합
   - TURN 엔드포인트 설정
   - 인증 파이프라인 구성
   - 라우팅 규칙 설정

3. 보안 구현
   - 토큰 기반 인증
   - 세션 관리
   - 접근 제어

4. 모니터링 설정
   - 메트릭 수집
   - 로깅 구성
   - 알림 설정

이러한 구현을 통해 안전하고 효율적인 TURN 서버 운영이 가능합니다. 