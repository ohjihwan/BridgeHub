import { useState, useEffect, useRef } from "react"
import io from "socket.io-client"

const Video = () => {
  const [isConnected, setIsConnected] = useState(false)
  const [connectionError, setConnectionError] = useState(null)
  const [currentView, setCurrentView] = useState("lobby") // 'lobby', 'room'
  const [nickname, setNickname] = useState("")
  const [roomName, setRoomName] = useState("")
  const [roomList, setRoomList] = useState([])
  const [currentRoom, setCurrentRoom] = useState(null)
  const [participants, setParticipants] = useState([])
  const [chatMessages, setChatMessages] = useState([])
  const [chatInput, setChatInput] = useState("")
  const [mediaState, setMediaState] = useState({ video: true, audio: true, screen: false })
  const [showRoomList, setShowRoomList] = useState(false)
  const [mediaError, setMediaError] = useState(null)
  const [permissionStatus, setPermissionStatus] = useState("checking")
  const [showRoomListInRoom, setShowRoomListInRoom] = useState(false)
  const [screenSharingUser, setScreenSharingUser] = useState(null) // í™”ë©´ê³µìœ  ì¤‘ì¸ ì‚¬ìš©ì

  const socketRef = useRef(null)
  const myStreamRef = useRef(null)
  const myScreenStreamRef = useRef(null)
  const myVideoRef = useRef(null)
  const peerConnectionsRef = useRef(new Map())
  const peerVideosRef = useRef(new Map())
  const peerScreenStreamsRef = useRef(new Map()) // í™”ë©´ê³µìœ  ìŠ¤íŠ¸ë¦¼ ì €ì¥

  // RTC ì„œë²„ ì£¼ì†Œ í•˜ë“œì½”ë”©
  const RTC_SERVER_URL = "http://192.168.0.58:7601"

  useEffect(() => {
    checkBrowserCompatibility()
    initializeSocket()
    return () => cleanup()
  }, [])

  // ì£¼ê¸°ì ìœ¼ë¡œ ë°© ëª©ë¡ ì—…ë°ì´íŠ¸ (5ì´ˆë§ˆë‹¤)
  useEffect(() => {
    const interval = setInterval(() => {
      if (socketRef.current && socketRef.current.connected) {
        getRoomList()
      }
    }, 5000)

    return () => clearInterval(interval)
  }, [])

  const checkBrowserCompatibility = async () => {
    console.log("ğŸ” Checking browser compatibility...")

    if (!navigator.mediaDevices) {
      console.error("âŒ navigator.mediaDevices not supported")
      setMediaError("ì´ ë¸Œë¼ìš°ì €ëŠ” ë¯¸ë””ì–´ ê¸°ëŠ¥ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Chrome, Firefox, Safari ìµœì‹  ë²„ì „ì„ ì‚¬ìš©í•´ì£¼ì„¸ìš”.")
      return
    }

    if (!navigator.mediaDevices.getUserMedia) {
      console.error("âŒ getUserMedia not supported")
      setMediaError("ì´ ë¸Œë¼ìš°ì €ëŠ” ì¹´ë©”ë¼/ë§ˆì´í¬ ì ‘ê·¼ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
      return
    }

    const isSecure =
      location.protocol === "https:" || location.hostname === "localhost" || location.hostname === "127.0.0.1"
    if (!isSecure) {
      console.warn("âš ï¸ Not running on HTTPS, media access might be restricted")
    }

    try {
      if (navigator.permissions) {
        const cameraPermission = await navigator.permissions.query({ name: "camera" })
        const microphonePermission = await navigator.permissions.query({ name: "microphone" })

        console.log("ğŸ“¹ Camera permission:", cameraPermission.state)
        console.log("ğŸ¤ Microphone permission:", microphonePermission.state)

        if (cameraPermission.state === "granted" && microphonePermission.state === "granted") {
          setPermissionStatus("granted")
        } else if (cameraPermission.state === "denied" || microphonePermission.state === "denied") {
          setPermissionStatus("denied")
        } else {
          setPermissionStatus("prompt")
        }
      } else {
        setPermissionStatus("prompt")
      }
    } catch (error) {
      console.log("ğŸ“‹ Permission API not available, will prompt for access")
      setPermissionStatus("prompt")
    }

    console.log("âœ… Browser compatibility check completed")
  }

  const initializeSocket = () => {
    try {
      socketRef.current = io(RTC_SERVER_URL, {
        transports: ["websocket", "polling"],
        timeout: 20000,
        forceNew: true,
      })

      socketRef.current.on("connect", () => {
        console.log("âœ… Connected to RTC server:", RTC_SERVER_URL)
        setIsConnected(true)
        setConnectionError(null)
        getRoomList()
      })

      socketRef.current.on("connect_error", (error) => {
        console.error("âŒ Connection error:", error)
        setConnectionError(`ì„œë²„ ì—°ê²° ì‹¤íŒ¨: ${error.message}`)
        setIsConnected(false)
      })

      socketRef.current.on("disconnect", (reason) => {
        console.log("ğŸ”Œ Disconnected:", reason)
        setIsConnected(false)
        if (reason === "io server disconnect") {
          socketRef.current.connect()
        }
      })

      socketRef.current.on("room-list", (rooms) => {
        console.log("ğŸ“‹ Room list received:", rooms.length, "rooms")
        setRoomList(rooms)
      })

      socketRef.current.on("room-created", ({ roomId, roomName, participants }) => {
        console.log("ğŸ  Room created:", roomId, "with name:", roomName)
        setCurrentRoom({ id: roomId, name: roomName })
        setParticipants(participants)
        setCurrentView("room")

        setTimeout(() => {
          getRoomList()
          initializeMedia()
        }, 500)
      })

      socketRef.current.on("room-joined", ({ roomId, roomName, participants }) => {
        console.log("ğŸ‘¤ Joined room:", roomId)
        setCurrentRoom({ id: roomId, name: roomName })
        setParticipants(participants)
        setCurrentView("room")

        setTimeout(() => {
          getRoomList()
          initializeMedia()
        }, 500)
      })

      socketRef.current.on("join-error", ({ message }) => {
        alert(`ì…ì¥ ì‹¤íŒ¨: ${message}`)
      })

      socketRef.current.on("user-joined", ({ participant, participants }) => {
        console.log("ğŸ‘‹ User joined:", participant.nickname)
        setParticipants(participants)
        addChatMessage("ì‹œìŠ¤í…œ", `${participant.nickname}ë‹˜ì´ ì…ì¥í–ˆìŠµë‹ˆë‹¤.`)
        getRoomList()

        setTimeout(() => {
          createPeerConnection(participant.id, participant.nickname, true)
        }, 1000)
      })

      socketRef.current.on("user-left", ({ participantId, nickname, participants }) => {
        console.log("ğŸ‘‹ User left:", nickname)
        setParticipants(participants)
        addChatMessage("ì‹œìŠ¤í…œ", `${nickname}ë‹˜ì´ ë°©ì„ ë‚˜ê°”ìŠµë‹ˆë‹¤.`)
        getRoomList()

        // í™”ë©´ê³µìœ  ì¤‘ì¸ ì‚¬ìš©ìê°€ ë‚˜ê°„ ê²½ìš°
        if (screenSharingUser && screenSharingUser.id === participantId) {
          setScreenSharingUser(null)
        }

        const peerConnection = peerConnectionsRef.current.get(participantId)
        if (peerConnection) {
          peerConnection.close()
          peerConnectionsRef.current.delete(participantId)
        }

        peerVideosRef.current.delete(participantId)
        peerScreenStreamsRef.current.delete(participantId)
      })

      socketRef.current.on("webrtc-signal", async ({ senderId, senderNickname, signal, type }) => {
        console.log(`ğŸ“¡ Received WebRTC signal: ${type} from ${senderNickname}`)

        let peerConnection = peerConnectionsRef.current.get(senderId)

        if (!peerConnection) {
          peerConnection = createPeerConnection(senderId, senderNickname, false)
        }

        try {
          if (type === "offer") {
            await peerConnection.setRemoteDescription(signal)
            const answer = await peerConnection.createAnswer()
            await peerConnection.setLocalDescription(answer)

            socketRef.current.emit("webrtc-signal", {
              targetId: senderId,
              signal: answer,
              type: "answer",
            })
          } else if (type === "answer") {
            await peerConnection.setRemoteDescription(signal)
          } else if (type === "ice-candidate") {
            await peerConnection.addIceCandidate(signal)
          }
        } catch (error) {
          console.error("WebRTC signal handling error:", error)
        }
      })

      socketRef.current.on("peer-media-state-changed", ({ peerId, nickname, video, audio, screen }) => {
        console.log(`ğŸ¥ ${nickname} media state:`, { video, audio, screen })

        // í™”ë©´ê³µìœ  ìƒíƒœ ì—…ë°ì´íŠ¸
        if (screen) {
          setScreenSharingUser({ id: peerId, nickname })
        } else if (screenSharingUser && screenSharingUser.id === peerId) {
          setScreenSharingUser(null)
        }
      })

      socketRef.current.on("chat-message", (chatData) => {
        addChatMessage(chatData.from, chatData.message, chatData.timestamp)
      })
    } catch (error) {
      console.error("Socket initialization error:", error)
      setConnectionError(`ì´ˆê¸°í™” ì‹¤íŒ¨: ${error.message}`)
    }
  }

  const initializeMedia = async () => {
    console.log("ğŸ¥ Initializing media...")
    setMediaError(null)

    try {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error("ë¸Œë¼ìš°ì €ê°€ ë¯¸ë””ì–´ ì ‘ê·¼ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
      }

      const constraints = {
        video: {
          width: { ideal: 1280, max: 1920 },
          height: { ideal: 720, max: 1080 },
          frameRate: { ideal: 30, max: 60 },
        },
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
        },
      }

      console.log("ğŸ“¹ Requesting media access with constraints:", constraints)

      const stream = await navigator.mediaDevices.getUserMedia(constraints)

      console.log("âœ… Media access granted")
      myStreamRef.current = stream

      if (myVideoRef.current) {
        myVideoRef.current.srcObject = stream
        console.log("ğŸ“º Video element connected to stream")
      }

      setPermissionStatus("granted")
      setMediaError(null)

      const videoTrack = stream.getVideoTracks()[0]
      const audioTrack = stream.getAudioTracks()[0]

      setMediaState({
        video: videoTrack ? videoTrack.enabled : false,
        audio: audioTrack ? audioTrack.enabled : false,
        screen: false,
      })

      console.log("ğŸ‰ Media initialization completed successfully")
    } catch (error) {
      console.error("âŒ Media access error:", error)

      let errorMessage = "ì¹´ë©”ë¼/ë§ˆì´í¬ ì ‘ê·¼ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."

      if (error.name === "NotAllowedError") {
        errorMessage = "ì¹´ë©”ë¼/ë§ˆì´í¬ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì„¤ì •ì—ì„œ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”."
        setPermissionStatus("denied")
      } else if (error.name === "NotFoundError") {
        errorMessage = "ì¹´ë©”ë¼ ë˜ëŠ” ë§ˆì´í¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì¥ì¹˜ê°€ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”."
      } else if (error.name === "NotReadableError") {
        errorMessage = "ì¹´ë©”ë¼/ë§ˆì´í¬ê°€ ë‹¤ë¥¸ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤."
      } else if (error.name === "OverconstrainedError") {
        errorMessage = "ìš”ì²­í•œ ë¯¸ë””ì–´ ì„¤ì •ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."
      } else if (error.name === "SecurityError") {
        errorMessage = "ë³´ì•ˆìƒì˜ ì´ìœ ë¡œ ë¯¸ë””ì–´ ì ‘ê·¼ì´ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤. HTTPS í™˜ê²½ì—ì„œ ì‹¤í–‰í•´ì£¼ì„¸ìš”."
      }

      setMediaError(errorMessage)

      if (error.name === "NotAllowedError") {
        showPermissionGuide()
      }
    }
  }

  const showPermissionGuide = () => {
    const guide = `
ğŸ”§ ì¹´ë©”ë¼/ë§ˆì´í¬ ê¶Œí•œ í—ˆìš© ë°©ë²•:

1. Chrome ì£¼ì†Œì°½ ì™¼ìª½ì˜ ğŸ”’ ë˜ëŠ” ğŸ¥ ì•„ì´ì½˜ í´ë¦­
2. "ì¹´ë©”ë¼" ë° "ë§ˆì´í¬"ë¥¼ "í—ˆìš©"ìœ¼ë¡œ ë³€ê²½
3. í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨
    `

    console.log(guide)
    alert("ì¹´ë©”ë¼/ë§ˆì´í¬ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤. ì½˜ì†”ì„ í™•ì¸í•˜ì—¬ ê¶Œí•œ í—ˆìš© ë°©ë²•ì„ ì°¸ê³ í•´ì£¼ì„¸ìš”.")
  }

  const requestMediaPermission = async () => {
    console.log("ğŸ”„ Requesting media permission...")
    await initializeMedia()
  }

  const createPeerConnection = (peerId, peerNickname, shouldCreateOffer) => {
    const peerConnection = new RTCPeerConnection({
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
        { urls: "stun:stun2.l.google.com:19302" },
      ],
    })

    peerConnection.onicecandidate = (event) => {
      if (event.candidate) {
        socketRef.current.emit("webrtc-signal", {
          targetId: peerId,
          signal: event.candidate,
          type: "ice-candidate",
        })
      }
    }

    peerConnection.ontrack = (event) => {
      console.log(`ğŸ¬ Received track from ${peerNickname}`)
      const stream = event.streams[0]

      // í™”ë©´ê³µìœ  ìŠ¤íŠ¸ë¦¼ì¸ì§€ ì¼ë°˜ ë¹„ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ì¸ì§€ êµ¬ë¶„
      const videoTrack = stream.getVideoTracks()[0]
      if (videoTrack && videoTrack.label.includes("screen")) {
        // í™”ë©´ê³µìœ  ìŠ¤íŠ¸ë¦¼
        peerScreenStreamsRef.current.set(peerId, {
          stream: stream,
          nickname: peerNickname,
        })
        setScreenSharingUser({ id: peerId, nickname: peerNickname })
      } else {
        // ì¼ë°˜ ë¹„ë””ì˜¤ ìŠ¤íŠ¸ë¦¼
        peerVideosRef.current.set(peerId, {
          stream: stream,
          nickname: peerNickname,
        })
      }

      setParticipants((prev) => [...prev])
    }

    // í˜„ì¬ ìŠ¤íŠ¸ë¦¼ ì¶”ê°€
    if (myStreamRef.current) {
      myStreamRef.current.getTracks().forEach((track) => {
        peerConnection.addTrack(track, myStreamRef.current)
      })
    }

    if (myScreenStreamRef.current) {
      myScreenStreamRef.current.getTracks().forEach((track) => {
        peerConnection.addTrack(track, myScreenStreamRef.current)
      })
    }

    peerConnectionsRef.current.set(peerId, peerConnection)

    if (shouldCreateOffer) {
      setTimeout(async () => {
        try {
          const offer = await peerConnection.createOffer()
          await peerConnection.setLocalDescription(offer)

          socketRef.current.emit("webrtc-signal", {
            targetId: peerId,
            signal: offer,
            type: "offer",
          })
        } catch (error) {
          console.error("Create offer error:", error)
        }
      }, 500)
    }

    return peerConnection
  }

  const createRoom = () => {
    if (!nickname.trim() || !roomName.trim()) {
      alert("ë‹‰ë„¤ì„ê³¼ ë°© ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.")
      return
    }

    if (!socketRef.current || !socketRef.current.connected) {
      alert("ì„œë²„ì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
      return
    }

    console.log("ğŸ  Creating room:", roomName.trim(), "by:", nickname.trim())

    socketRef.current.emit("create-room", {
      roomName: roomName.trim(),
      nickname: nickname.trim(),
    })
  }

  const joinRoom = (roomId) => {
    if (!nickname.trim()) {
      alert("ë‹‰ë„¤ì„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.")
      return
    }

    if (!socketRef.current || !socketRef.current.connected) {
      alert("ì„œë²„ì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
      return
    }

    socketRef.current.emit("join-room", {
      roomId,
      nickname: nickname.trim(),
    })
  }

  const getRoomList = () => {
    if (socketRef.current && socketRef.current.connected) {
      console.log("ğŸ“‹ Requesting room list...")
      socketRef.current.emit("get-room-list")
    }
  }

  const toggleVideo = () => {
    if (myStreamRef.current) {
      const videoTrack = myStreamRef.current.getVideoTracks()[0]
      if (videoTrack) {
        videoTrack.enabled = !videoTrack.enabled
        const newState = { ...mediaState, video: videoTrack.enabled }
        setMediaState(newState)
        notifyMediaStateChange(newState)
      }
    }
  }

  const toggleAudio = () => {
    if (myStreamRef.current) {
      const audioTrack = myStreamRef.current.getAudioTracks()[0]
      if (audioTrack) {
        audioTrack.enabled = !audioTrack.enabled
        const newState = { ...mediaState, audio: audioTrack.enabled }
        setMediaState(newState)
        notifyMediaStateChange(newState)
      }
    }
  }

  const toggleScreenShare = async () => {
    try {
      if (!mediaState.screen) {
        // í™”ë©´ê³µìœ  ì‹œì‘
        const screenStream = await navigator.mediaDevices.getDisplayMedia({
          video: true,
          audio: true,
        })

        myScreenStreamRef.current = screenStream
        setScreenSharingUser({ id: "me", nickname: nickname })

        // ê¸°ì¡´ ë¹„ë””ì˜¤ íŠ¸ë™ì„ í™”ë©´ê³µìœ  íŠ¸ë™ìœ¼ë¡œ êµì²´
        peerConnectionsRef.current.forEach((peerConnection) => {
          const sender = peerConnection.getSenders().find((s) => s.track && s.track.kind === "video")
          if (sender) {
            sender.replaceTrack(screenStream.getVideoTracks()[0])
          }
        })

        // ë‚´ ë¹„ë””ì˜¤ ì—˜ë¦¬ë¨¼íŠ¸ë„ í™”ë©´ê³µìœ ë¡œ ë³€ê²½
        if (myVideoRef.current) {
          myVideoRef.current.srcObject = screenStream
        }

        screenStream.getVideoTracks()[0].onended = () => {
          stopScreenShare()
        }

        const newState = { ...mediaState, screen: true }
        setMediaState(newState)
        notifyMediaStateChange(newState)
      } else {
        stopScreenShare()
      }
    } catch (error) {
      console.error("Screen share error:", error)
      alert("í™”ë©´ ê³µìœ ë¥¼ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    }
  }

  const stopScreenShare = async () => {
    if (myScreenStreamRef.current) {
      myScreenStreamRef.current.getTracks().forEach((track) => track.stop())
      myScreenStreamRef.current = null
    }

    setScreenSharingUser(null)

    // í™”ë©´ê³µìœ  íŠ¸ë™ì„ ë‹¤ì‹œ ì¼ë°˜ ë¹„ë””ì˜¤ íŠ¸ë™ìœ¼ë¡œ êµì²´
    if (myStreamRef.current) {
      const videoTrack = myStreamRef.current.getVideoTracks()[0]

      peerConnectionsRef.current.forEach((peerConnection) => {
        const sender = peerConnection.getSenders().find((s) => s.track && s.track.kind === "video")
        if (sender && videoTrack) {
          sender.replaceTrack(videoTrack)
        }
      })

      // ë‚´ ë¹„ë””ì˜¤ ì—˜ë¦¬ë¨¼íŠ¸ë„ ì¼ë°˜ ë¹„ë””ì˜¤ë¡œ ë³µì›
      if (myVideoRef.current) {
        myVideoRef.current.srcObject = myStreamRef.current
      }
    }

    const newState = { ...mediaState, screen: false }
    setMediaState(newState)
    notifyMediaStateChange(newState)
  }

  const notifyMediaStateChange = (state) => {
    if (socketRef.current && socketRef.current.connected) {
      socketRef.current.emit("media-state-changed", state)
    }
  }

  const sendChat = () => {
    const message = chatInput.trim()
    if (!message) return

    if (socketRef.current && socketRef.current.connected) {
      socketRef.current.emit("chat-message", { message })
      setChatInput("")
    }
  }

  const addChatMessage = (from, message, timestamp = null) => {
    const time = timestamp ? new Date(timestamp) : new Date()
    const timeString = time.toLocaleTimeString("ko-KR", {
      hour: "2-digit",
      minute: "2-digit",
      hour12: false,
    })

    setChatMessages((prev) => [
      ...prev,
      {
        id: Date.now() + Math.random(),
        from,
        message,
        time: timeString,
      },
    ])
  }

  const leaveRoom = () => {
    if (socketRef.current && socketRef.current.connected) {
      socketRef.current.emit("leave-room")
    }

    if (myStreamRef.current) {
      myStreamRef.current.getTracks().forEach((track) => track.stop())
      myStreamRef.current = null
    }

    if (myScreenStreamRef.current) {
      myScreenStreamRef.current.getTracks().forEach((track) => track.stop())
      myScreenStreamRef.current = null
    }

    peerConnectionsRef.current.forEach((pc) => pc.close())
    peerConnectionsRef.current.clear()
    peerVideosRef.current.clear()
    peerScreenStreamsRef.current.clear()

    setCurrentRoom(null)
    setParticipants([])
    setChatMessages([])
    setMediaState({ video: true, audio: true, screen: false })
    setCurrentView("lobby")
    setMediaError(null)
    setShowRoomListInRoom(false)
    setScreenSharingUser(null)

    setTimeout(() => {
      getRoomList()
    }, 500)
  }

  const cleanup = () => {
    if (socketRef.current) {
      socketRef.current.disconnect()
    }

    if (myStreamRef.current) {
      myStreamRef.current.getTracks().forEach((track) => track.stop())
    }

    if (myScreenStreamRef.current) {
      myScreenStreamRef.current.getTracks().forEach((track) => track.stop())
    }

    peerConnectionsRef.current.forEach((pc) => pc.close())
  }

  // ë¹„ë””ì˜¤ ê·¸ë¦¬ë“œ ë ˆì´ì•„ì›ƒ ê³„ì‚° (3ê°œì”© í–‰ìœ¼ë¡œ ë°°ì¹˜)
  const getVideoGridStyle = (totalVideos) => {
    if (screenSharingUser) {
      // í™”ë©´ê³µìœ  ì¤‘ì¼ ë•ŒëŠ” 2ì—´ ë ˆì´ì•„ì›ƒ (í™”ë©´ê³µìœ  + ì‘ì€ ë¹„ë””ì˜¤ë“¤)
      return {
        display: "grid",
        gridTemplateColumns: "2fr 1fr",
        gap: "20px",
        marginBottom: "20px",
      }
    } else {
      // ì¼ë°˜ ìƒíƒœì—ì„œëŠ” 3ê°œì”© í–‰ìœ¼ë¡œ ë°°ì¹˜
      return {
        display: "grid",
        gridTemplateColumns: "repeat(3, 1fr)",
        gap: "20px",
        marginBottom: "20px",
      }
    }
  }

  // ë‹¤í¬ í…Œë§ˆ ìŠ¤íƒ€ì¼
  const styles = {
    container: {
      fontFamily: "Arial, sans-serif",
      padding: "20px",
      maxWidth: "1400px",
      margin: "0 auto",
      backgroundColor: "#1a1a1a",
      minHeight: "100vh",
      color: "#ffffff",
    },
    header: {
      textAlign: "center",
      marginBottom: "30px",
      backgroundColor: "#2d2d2d",
      padding: "20px",
      borderRadius: "10px",
      boxShadow: "0 4px 20px rgba(0,0,0,0.3)",
      border: "1px solid #404040",
    },
    title: {
      color: "#ffffff",
      marginBottom: "10px",
      fontSize: "28px",
    },
    connectionStatus: {
      padding: "10px",
      borderRadius: "5px",
      marginBottom: "10px",
      textAlign: "center",
      fontWeight: "bold",
    },
    connected: {
      backgroundColor: "#1e4d3a",
      color: "#4ade80",
      border: "1px solid #22c55e",
    },
    disconnected: {
      backgroundColor: "#4a1e1e",
      color: "#f87171",
      border: "1px solid #ef4444",
    },
    mediaGranted: {
      backgroundColor: "#1e3a4d",
      color: "#60a5fa",
      border: "1px solid #3b82f6",
    },
    mediaDenied: {
      backgroundColor: "#4a1e1e",
      color: "#f87171",
      border: "1px solid #ef4444",
    },
    mediaPrompt: {
      backgroundColor: "#4a3d1e",
      color: "#fbbf24",
      border: "1px solid #f59e0b",
    },
    inputGroup: {
      display: "flex",
      gap: "10px",
      justifyContent: "center",
      alignItems: "center",
      flexWrap: "wrap",
      marginBottom: "20px",
    },
    input: {
      padding: "12px",
      border: "2px solid #404040",
      borderRadius: "8px",
      fontSize: "16px",
      minWidth: "200px",
      backgroundColor: "#3d3d3d",
      color: "#ffffff",
    },
    button: {
      padding: "12px 20px",
      border: "none",
      borderRadius: "8px",
      cursor: "pointer",
      fontSize: "16px",
      fontWeight: "bold",
      transition: "all 0.3s ease",
    },
    primaryButton: {
      backgroundColor: "#3b82f6",
      color: "white",
    },
    successButton: {
      backgroundColor: "#22c55e",
      color: "white",
    },
    dangerButton: {
      backgroundColor: "#ef4444",
      color: "white",
    },
    warningButton: {
      backgroundColor: "#f59e0b",
      color: "#1a1a1a",
    },
    disabledButton: {
      backgroundColor: "#6b7280",
      color: "#9ca3af",
      cursor: "not-allowed",
    },
    infoButton: {
      backgroundColor: "#06b6d4",
      color: "white",
    },
    roomListContainer: {
      backgroundColor: "#2d2d2d",
      padding: "20px",
      borderRadius: "10px",
      boxShadow: "0 4px 20px rgba(0,0,0,0.3)",
      marginBottom: "20px",
      border: "1px solid #404040",
    },
    roomItem: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      padding: "15px",
      border: "1px solid #404040",
      borderRadius: "8px",
      marginBottom: "10px",
      backgroundColor: "#3d3d3d",
    },
    currentRoomItem: {
      backgroundColor: "#1e3a4d",
      border: "2px solid #3b82f6",
    },
    roomInfo: {
      flex: 1,
    },
    roomName: {
      fontWeight: "bold",
      fontSize: "18px",
      marginBottom: "5px",
      color: "#ffffff",
    },
    roomDetails: {
      color: "#9ca3af",
      fontSize: "14px",
    },
    videoGrid: getVideoGridStyle(participants.length + 1),
    videoContainer: {
      backgroundColor: "#2d2d2d",
      borderRadius: "10px",
      padding: "15px",
      boxShadow: "0 4px 20px rgba(0,0,0,0.3)",
      textAlign: "center",
      border: "1px solid #404040",
    },
    screenShareContainer: {
      backgroundColor: "#2d2d2d",
      borderRadius: "10px",
      padding: "15px",
      boxShadow: "0 4px 20px rgba(0,0,0,0.3)",
      textAlign: "center",
      border: "2px solid #f59e0b",
    },
    smallVideoContainer: {
      backgroundColor: "#2d2d2d",
      borderRadius: "8px",
      padding: "10px",
      marginBottom: "10px",
      border: "1px solid #404040",
    },
    video: {
      width: "100%",
      height: "200px",
      backgroundColor: "#000",
      borderRadius: "8px",
      objectFit: "cover",
    },
    screenShareVideo: {
      width: "100%",
      height: "400px",
      backgroundColor: "#000",
      borderRadius: "8px",
      objectFit: "contain",
    },
    smallVideo: {
      width: "100%",
      height: "120px",
      backgroundColor: "#000",
      borderRadius: "6px",
      objectFit: "cover",
    },
    videoLabel: {
      marginTop: "10px",
      fontWeight: "bold",
      color: "#ffffff",
    },
    controlPanel: {
      display: "flex",
      gap: "10px",
      justifyContent: "center",
      flexWrap: "wrap",
      marginBottom: "20px",
      backgroundColor: "#2d2d2d",
      padding: "20px",
      borderRadius: "10px",
      boxShadow: "0 4px 20px rgba(0,0,0,0.3)",
      border: "1px solid #404040",
    },
    participantsList: {
      backgroundColor: "#2d2d2d",
      padding: "20px",
      borderRadius: "10px",
      boxShadow: "0 4px 20px rgba(0,0,0,0.3)",
      marginBottom: "20px",
      border: "1px solid #404040",
    },
    participantItem: {
      padding: "10px",
      borderBottom: "1px solid #404040",
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      color: "#ffffff",
    },
    chatContainer: {
      backgroundColor: "#2d2d2d",
      borderRadius: "10px",
      boxShadow: "0 4px 20px rgba(0,0,0,0.3)",
      padding: "20px",
      border: "1px solid #404040",
    },
    chatBox: {
      height: "200px",
      border: "1px solid #404040",
      borderRadius: "8px",
      padding: "15px",
      overflowY: "auto",
      marginBottom: "15px",
      backgroundColor: "#3d3d3d",
      color: "#ffffff",
    },
    chatInputContainer: {
      display: "flex",
      gap: "10px",
    },
    chatInput: {
      flex: 1,
      padding: "12px",
      border: "1px solid #404040",
      borderRadius: "8px",
      fontSize: "16px",
      backgroundColor: "#3d3d3d",
      color: "#ffffff",
    },
    errorContainer: {
      backgroundColor: "#4a1e1e",
      color: "#f87171",
      border: "1px solid #ef4444",
      borderRadius: "5px",
      padding: "15px",
      marginBottom: "20px",
    },
  }

  // ì—°ê²° ìƒíƒœ í‘œì‹œ
  const renderConnectionStatus = () => (
    <div
      style={{
        ...styles.connectionStatus,
        ...(isConnected ? styles.connected : styles.disconnected),
      }}
    >
      {isConnected
        ? `âœ… RTC ì„œë²„ ì—°ê²°ë¨ (${RTC_SERVER_URL})`
        : `âŒ RTC ì„œë²„ ì—°ê²° ì‹¤íŒ¨ ${connectionError ? `- ${connectionError}` : ""}`}
    </div>
  )

  // ë¯¸ë””ì–´ ìƒíƒœ í‘œì‹œ
  const renderMediaStatus = () => {
    let statusStyle, statusText

    if (permissionStatus === "granted") {
      statusStyle = styles.mediaGranted
      statusText = "ğŸ¥ ì¹´ë©”ë¼/ë§ˆì´í¬ ê¶Œí•œ í—ˆìš©ë¨"
    } else if (permissionStatus === "denied") {
      statusStyle = styles.mediaDenied
      statusText = "âŒ ì¹´ë©”ë¼/ë§ˆì´í¬ ê¶Œí•œ ê±°ë¶€ë¨"
    } else if (permissionStatus === "prompt") {
      statusStyle = styles.mediaPrompt
      statusText = "â³ ì¹´ë©”ë¼/ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­ ì¤‘"
    } else {
      statusStyle = styles.mediaPrompt
      statusText = "ğŸ” ë¸Œë¼ìš°ì € í˜¸í™˜ì„± í™•ì¸ ì¤‘"
    }

    return <div style={{ ...styles.connectionStatus, ...statusStyle }}>{statusText}</div>
  }

  // ë°© ëª©ë¡ ë Œë”ë§
  const renderRoomList = () => (
    <div style={styles.roomListContainer}>
      <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "15px" }}>
        <h3 style={{ color: "#ffffff" }}>ì°¸ì—¬ ê°€ëŠ¥í•œ ë°© ëª©ë¡ ({roomList.length}ê°œ)</h3>
        <button style={{ ...styles.button, ...styles.infoButton }} onClick={getRoomList} disabled={!isConnected}>
          ğŸ”„ ìƒˆë¡œê³ ì¹¨
        </button>
      </div>

      {roomList.length === 0 ? (
        <p style={{ color: "#9ca3af" }}>í˜„ì¬ ìƒì„±ëœ ë°©ì´ ì—†ìŠµë‹ˆë‹¤.</p>
      ) : (
        roomList.map((room) => {
          const isCurrentRoom = currentRoom && room.id === currentRoom.id
          return (
            <div
              key={room.id}
              style={{
                ...styles.roomItem,
                ...(isCurrentRoom ? styles.currentRoomItem : {}),
              }}
            >
              <div style={styles.roomInfo}>
                <div style={styles.roomName}>
                  {room.name} {isCurrentRoom && "(í˜„ì¬ ë°©)"}
                </div>
                <div style={styles.roomDetails}>
                  ì°¸ì—¬ì: {room.participantCount}/{room.maxParticipants} | ìƒì„±ì‹œê°„:{" "}
                  {new Date(room.createdAt).toLocaleString("ko-KR")}
                </div>
              </div>
              {!isCurrentRoom && (
                <button
                  style={{
                    ...styles.button,
                    ...(room.participantCount >= room.maxParticipants || !isConnected
                      ? styles.disabledButton
                      : styles.successButton),
                  }}
                  onClick={() => joinRoom(room.id)}
                  disabled={room.participantCount >= room.maxParticipants || !isConnected}
                >
                  {room.participantCount >= room.maxParticipants ? "ê°€ë“ì°¸" : "ì…ì¥"}
                </button>
              )}
            </div>
          )
        })
      )}
    </div>
  )

  // ë¹„ë””ì˜¤ ê·¸ë¦¬ë“œ ë Œë”ë§
  const renderVideoGrid = () => {
    const allParticipants = [
      { id: "me", nickname: nickname, isMe: true },
      ...participants.filter((p) => p.nickname !== nickname),
    ]

    if (screenSharingUser) {
      // í™”ë©´ê³µìœ  ì¤‘ì¼ ë•Œ ë ˆì´ì•„ì›ƒ
      return (
        <div style={styles.videoGrid}>
          {/* í™”ë©´ê³µìœ  ë¹„ë””ì˜¤ (í° í™”ë©´) */}
          <div style={styles.screenShareContainer}>
            <video
              ref={screenSharingUser.id === "me" ? myVideoRef : null}
              style={styles.screenShareVideo}
              autoPlay
              playsInline
              muted={screenSharingUser.id === "me"}
              srcObject={
                screenSharingUser.id === "me" ? null : peerScreenStreamsRef.current.get(screenSharingUser.id)?.stream
              }
            />
            <div style={styles.videoLabel}>ğŸ–¥ï¸ {screenSharingUser.nickname}ì˜ í™”ë©´ê³µìœ </div>
          </div>

          {/* ì‘ì€ ë¹„ë””ì˜¤ë“¤ */}
          <div>
            {allParticipants.map((participant) => {
              if (participant.id === screenSharingUser.id) return null

              return (
                <div key={participant.id} style={styles.smallVideoContainer}>
                  <video
                    ref={participant.isMe ? myVideoRef : null}
                    style={styles.smallVideo}
                    autoPlay
                    playsInline
                    muted={participant.isMe}
                    srcObject={participant.isMe ? null : peerVideosRef.current.get(participant.id)?.stream}
                  />
                  <div style={styles.videoLabel}>
                    {participant.nickname} {participant.isMe && "(ë‚˜)"}
                  </div>
                </div>
              )
            })}
          </div>
        </div>
      )
    } else {
      // ì¼ë°˜ ë¹„ë””ì˜¤ ê·¸ë¦¬ë“œ (3ê°œì”© í–‰ìœ¼ë¡œ ë°°ì¹˜)
      return (
        <div style={styles.videoGrid}>
          {allParticipants.map((participant) => (
            <div key={participant.id} style={styles.videoContainer}>
              <video
                ref={participant.isMe ? myVideoRef : null}
                style={styles.video}
                autoPlay
                playsInline
                muted={participant.isMe}
                srcObject={participant.isMe ? null : peerVideosRef.current.get(participant.id)?.stream}
              />
              <div style={styles.videoLabel}>
                {participant.nickname} {participant.isMe && "(ë‚˜)"}
              </div>
            </div>
          ))}
        </div>
      )
    }
  }

  if (currentView === "lobby") {
    return (
      <div style={styles.container}>
        <div style={styles.header}>
          <h1 style={styles.title}>WebRTC P2P í™”ìƒíšŒì˜</h1>
          {renderConnectionStatus()}
          {renderMediaStatus()}

          {mediaError && (
            <div style={styles.errorContainer}>
              <strong>ë¯¸ë””ì–´ ì˜¤ë¥˜:</strong> {mediaError}
              <br />
              <button
                style={{ ...styles.button, ...styles.warningButton, marginTop: "10px" }}
                onClick={requestMediaPermission}
              >
                ğŸ”„ ê¶Œí•œ ì¬ìš”ì²­
              </button>
            </div>
          )}

          <div style={styles.inputGroup}>
            <input
              style={styles.input}
              type="text"
              placeholder="ë‹‰ë„¤ì„ ì…ë ¥"
              value={nickname}
              onChange={(e) => setNickname(e.target.value)}
            />
            <input
              style={styles.input}
              type="text"
              placeholder="ë°© ì´ë¦„ ì…ë ¥"
              value={roomName}
              onChange={(e) => setRoomName(e.target.value)}
            />
            <button
              style={{
                ...styles.button,
                ...(isConnected ? styles.primaryButton : styles.disabledButton),
              }}
              onClick={createRoom}
              disabled={!isConnected}
            >
              ë°© ë§Œë“¤ê¸°
            </button>
            <button
              style={{
                ...styles.button,
                ...(isConnected ? styles.successButton : styles.disabledButton),
              }}
              onClick={() => {
                setShowRoomList(!showRoomList)
                if (!showRoomList && isConnected) getRoomList()
              }}
              disabled={!isConnected}
            >
              ë°© ëª©ë¡ {showRoomList ? "ìˆ¨ê¸°ê¸°" : "ë³´ê¸°"}
            </button>
          </div>
        </div>

        {showRoomList && renderRoomList()}
      </div>
    )
  }

  return (
    <div style={styles.container}>
      <div style={styles.header}>
        <h1 style={styles.title}>ë°©: {currentRoom?.name}</h1>
        <p style={{ color: "#9ca3af" }}>ë‹‰ë„¤ì„: {nickname}</p>
        {renderConnectionStatus()}
        {renderMediaStatus()}

        {mediaError && (
          <div style={styles.errorContainer}>
            <strong>ë¯¸ë””ì–´ ì˜¤ë¥˜:</strong> {mediaError}
            <br />
            <button
              style={{ ...styles.button, ...styles.warningButton, marginTop: "10px" }}
              onClick={requestMediaPermission}
            >
              ğŸ”„ ê¶Œí•œ ì¬ìš”ì²­
            </button>
          </div>
        )}
      </div>

      <div style={styles.controlPanel}>
        <button
          style={{ ...styles.button, ...(mediaState.video ? styles.dangerButton : styles.successButton) }}
          onClick={toggleVideo}
          disabled={!myStreamRef.current}
        >
          ğŸ“¹ ë¹„ë””ì˜¤ {mediaState.video ? "OFF" : "ON"}
        </button>
        <button
          style={{ ...styles.button, ...(mediaState.audio ? styles.dangerButton : styles.successButton) }}
          onClick={toggleAudio}
          disabled={!myStreamRef.current}
        >
          ğŸ¤ ì˜¤ë””ì˜¤ {mediaState.audio ? "OFF" : "ON"}
        </button>
        <button
          style={{ ...styles.button, ...(mediaState.screen ? styles.dangerButton : styles.warningButton) }}
          onClick={toggleScreenShare}
        >
          ğŸ–¥ï¸ í™”ë©´ê³µìœ  {mediaState.screen ? "OFF" : "ON"}
        </button>
        <button
          style={{ ...styles.button, ...styles.infoButton }}
          onClick={() => {
            setShowRoomListInRoom(!showRoomListInRoom)
            if (!showRoomListInRoom) getRoomList()
          }}
        >
          ğŸ“‹ ë°© ëª©ë¡ {showRoomListInRoom ? "ìˆ¨ê¸°ê¸°" : "ë³´ê¸°"}
        </button>
        <button style={{ ...styles.button, ...styles.dangerButton }} onClick={leaveRoom}>
          ğŸšª ë°© ë‚˜ê°€ê¸°
        </button>
      </div>

      {/* ë°© ì•ˆì—ì„œë„ ë°© ëª©ë¡ ë³´ê¸° */}
      {showRoomListInRoom && renderRoomList()}

      {/* ë¹„ë””ì˜¤ ê·¸ë¦¬ë“œ */}
      {renderVideoGrid()}

      <div style={styles.participantsList}>
        <h3 style={{ color: "#ffffff" }}>ì°¸ì—¬ì ëª©ë¡ ({participants.length}/10)</h3>
        {participants.map((participant) => (
          <div key={participant.id} style={styles.participantItem}>
            <span>
              {participant.nickname}
              {participant.isHost && " (ë°©ì¥)"}
              {screenSharingUser && screenSharingUser.id === participant.id && " ğŸ–¥ï¸"}
            </span>
          </div>
        ))}
      </div>

      <div style={styles.chatContainer}>
        <h3 style={{ color: "#ffffff" }}>ì±„íŒ…</h3>
        <div style={styles.chatBox}>
          {chatMessages.map((msg) => (
            <div key={msg.id}>
              [{msg.time}] {msg.from}: {msg.message}
            </div>
          ))}
        </div>
        <div style={styles.chatInputContainer}>
          <input
            style={styles.chatInput}
            type="text"
            value={chatInput}
            onChange={(e) => setChatInput(e.target.value)}
            onKeyPress={(e) => e.key === "Enter" && sendChat()}
            placeholder="ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
          />
          <button style={{ ...styles.button, ...styles.primaryButton }} onClick={sendChat}>
            ì „ì†¡
          </button>
        </div>
      </div>
    </div>
  )
}

export default Video
