<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>WebRTC ÌôîÎ©¥Í≥µÏú†</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìπ</text></svg>">
    <style>
      * {
        margin:0;
        padding:0;
        box-sizing: border-box;
      }
      html {font-size:16px;}
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        margin: 0;
        padding-top:50px;
        background: #fff;
        min-height: 100vh;
        color: #333333;
        background-color:#333;
      }
      
      .header {
        position:fixed;
        left:0;
        top:0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        width:100%;
        height:50px;
        margin-bottom: 24px;
        flex-wrap: wrap;
        gap: 16px;
      }
      
      h1#title {
        position:fixed;
        left:0;
        top:5px;
        padding:0 16px;
        color: #fff;
        height:40px;
        font-size: 14px;
        font-weight: 600;
        margin: 0;
        width:calc(100% - 180px);
        text-align:left;
        word-break:keep-all;
        display:-webkit-box;
        -webkit-line-clamp:2;
        -webkit-box-orient:vertical;
        overflow:hidden;
        text-overflow:ellipsis;
        overflow:hidden;
      }
      
      .timer-container {
        position:fixed;
        right:0;
        top:0;
        background: rgba(102, 126, 234, 0.1);
        border: 1px solid rgba(102, 126, 234, 0.2);
        border-radius:0 0 0 12px;
        height:50px;
        padding: 3px 0;
        display: flex;
        justify-content:center;
        width: 180px;
        color: #667eea;
        text-wrap:nowrap;
      }
      
      .timer-icon {
        font-size: 1.1rem;
      }
      
      .timer-text {
        font-weight: 600;
        font-size: 13px;
      }
      
      .timer-warning {
        background: rgba(255, 193, 7, 0.1);
        border-color: rgba(255, 193, 7, 0.3);
        color: #ffc107;
      }
      
      .timer-danger {
        background: rgba(220, 53, 69, 0.1);
        border-color: rgba(220, 53, 69, 0.3);
        color: #dc3545;
        animation: pulse-danger 1s infinite;
      }
      
      @keyframes pulse-danger {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
      }
      
      .controls {
        position:fixed;
        left:50%;
        bottom:24px;
        transform:translateX(-50%);
        z-index:100;
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 8px;
        width:100%;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      }
      
      .controls button {
        display:flex;
        justify-content:center;
        align-items:center;
        width:48px;
        height:48px;
        border: 1px solid #e1e5e9;
        border-radius: 50%;
        font-size: 24px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        background: #ffffff;
        color: #333333;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      }
      #toggle-camera{
        padding-bottom:8px;
      }
      
      .controls button:hover {
        background: #f8f9fa;
        border-color: #007fff;
        transform: translateY(-1px);
      }
      
      .controls button.active {
        background-color: #007fff;
        color: #fff;
        border-color: #007fff;
      }
      
      .controls button.danger {
        background: #dc3545;
        color: #fff;
        border-color: #dc3545;
      }
      
      .controls button.danger:hover {
        background: #c82333;
      }
      
      /* Î™®Î∞îÏùº Ïä§ÏôÄÏù¥ÌîÑ Ïª®ÌÖåÏù¥ÎÑà */
      .mobile-container {
        display:flex;
        position: relative;
        overflow: hidden;
        height:calc(100vh - 150px);
        padding: 15px 10px 0 10px;
      }
      
      .swipe-wrapper {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        transition: transform 0.3s ease;
        width: 100%;
        height: 100%;
      }
      
      .swipe-wrapper.layout-1 .video-slide {
        width: 100%;
        height: 100%;
      }
      
      .swipe-wrapper.layout-2 {
        flex-direction: column;
      }
      .swipe-wrapper.layout-2 .video-slide {
        width: 100%;
        height: calc(50% - 5px);
      }
      
      .swipe-wrapper.layout-3,
      .swipe-wrapper.layout-5,
      .swipe-wrapper.layout-7,
      .swipe-wrapper.layout-9 {
        justify-content: center;
      }
      
      .video-slide {
        overflow: hidden;
        width: calc(50% - 5px);
        height: calc(50% - 5px);
        position: relative;
        background: #222;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 10px;
        min-height: 200px;
      }
      
      .video-slide video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 10px;
      }
      
      .video-slide.empty {
        background: #222;
        color: #888;
        font-size: 1.2rem;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        border-radius: 10px;
      }
      
      .video-slide.empty::before {
        content: "üë§";
        font-size: 3rem;
        opacity: 0.3;
        margin-bottom: 10px;
      }
      
      .nickname-label {
        position: absolute;
        bottom: 6px;
        left: 6px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 6px 6px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        z-index: 10;
      }
      
      .swipe-indicators {
        display: none;
        justify-content: center;
        gap: 8px;
        padding: 16px;
        background: rgba(255, 255, 255, 0.9);
      }
      
      .swipe-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #cccccc;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      
      .swipe-dot.active {
        background: #667eea;
        transform: scale(1.3);
      }
      
      .connection-status {
        text-align: left;
      }
      [class^="status"] {
        position:fixed;
        right:17px;
        top:23px;
      }
      
      .status-connecting {
        color: #ffc107;
      }
      
      .status-connected {
        color: #28a745;
      }
      
      .status-error {
        color: #dc3545;
      }
      
      /* Ï±ÑÌåÖ Ìå®ÎÑê */
      #chat-panel {
        position: fixed;
        top: 0;
        right: -300px;
        width: 280px;
        height: 100%;
        background: #36393f;
        border-left: 1px solid #40444b;
        box-shadow: -4px 0 6px -1px rgb(0 0 0 / 0.3);
        transition: right 0.3s ease;
        display: flex;
        flex-direction: column;
        z-index: 999;
      }
      
      #chat-panel.open {
        right: 0;
      }
      
      .chat-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px;
        background: #2f3136;
        border-bottom: 1px solid #40444b;
        color: #ffffff;
        font-weight: 600;
        font-size: 16px;
      }
      
      .chat-close {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
        width: 32px;
        height: 32px;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }
      
      .chat-close:hover {
        background: rgba(255, 255, 255, 0.2);
      }
      
      #chat-box {
        flex: 1;
        padding: 20px;
        overflow-y: auto;
        background: #36393f;
        font-size: 14px;
        line-height: 1.5;
      }
      
      #chat-box p {
        margin: 8px 0;
        padding: 12px 16px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: #dcddde;
      }
      
      .chat-input-wrapper {
        display: flex;
        border-top: 1px solid #40444b;
        background: #2f3136;
      }
      
      #chat-input {
        flex: 1;
        padding: 16px;
        border: none;
        background: transparent;
        font-size: 14px;
        outline: none;
        color: #dcddde;
      }
      
      #chat-input::placeholder {
        color: #72767d;
      }
      
      .chat-input-wrapper button {
        padding: 16px 20px;
        border: none;
        background: #5865f2;
        color: white;
        cursor: pointer;
        font-weight: 500;
        font-size: 14px;
        transition: all 0.2s ease;
      }
      
      .chat-input-wrapper button:hover {
        background: #007fff;
      }
      
      /* ÎîîÎ≤ÑÍ∑∏ Ï†ïÎ≥¥ */
      .debug-info {
        position: fixed;
        bottom:0;
        left:0;
        color: #fff;
        font-size: 15px;
        padding-right:7px;
        z-index: 1000;
        border-radius:0 10px 0 0;
        background-color:rgba(0, 0, 0, 0.7);
        white-space:nowrap;
        text-overflow:hidden;
        text-overflow:ellipsis;
      }
      .debug-info div {
        display:inline-block;
        font-size:12px;
      }
      .debug-info div::after {
        content:' / ';
      }
      .debug-info div:last-child::after {
        display: none;
      }
    </style>
  </head>

<body>
    <!-- ÎîîÎ≤ÑÍ∑∏ Ï†ïÎ≥¥ -->
    <div class="debug-info" id="debug-info">
      <div>Ïó∞Í≤∞ ÏÉÅÌÉú: <span id="debug-connection">Ï¥àÍ∏∞Ìôî Ï§ë</span></div>
      <div>ÎÇ¥ Ïä§Ìä∏Î¶º: <span id="debug-my-stream">ÏóÜÏùå</span></div>
      <div>ÏÉÅÎåÄ Ïä§Ìä∏Î¶º: <span id="debug-remote-stream">ÏóÜÏùå</span></div>
      <div>ICE ÏÉÅÌÉú: <span id="debug-ice">ÏóÜÏùå</span></div>
      <div>Ïó≠Ìï†: <span id="debug-role">ÎåÄÍ∏∞Ï§ë</span></div>
    </div>

    <div class="header">
      <h1 id="title">Ïó∞Í≤∞ Ï§ë...</h1>
      <div class="timer-container" id="timer-container">
        <span class="timer-icon">‚è∞</span>
        <span class="timer-text" id="timer-display">ÌöåÏùò ÏãúÍ∞Ñ: 2ÏãúÍ∞Ñ 00Î∂Ñ</span>
      </div>
    </div>
    
    <div class="controls">
      <button id="toggle-camera" onclick="toggleCamera()" class="active">üì∑</button>
      <button id="toggle-mic" onclick="toggleMic()" class="active">üé§</button>
      <button id="screen-share-btn" onclick="toggleScreenShare()">üñ•Ô∏è</button>
      <button onclick="toggleChat()">üí¨</button>
      <button onclick="leaveRoom()" class="danger">üö™</button>
    </div>
    
    <div class="connection-status" id="connection-status">
      <div class="status-connecting">üì° Ïó∞Í≤∞ Ï§ë...</div>
    </div>
    
    <!-- Î™®Î∞îÏùº Ïä§ÏôÄÏù¥ÌîÑ Ïª®ÌÖåÏù¥ÎÑà -->
    <div class="mobile-container">
      <div class="swipe-wrapper" id="swipe-wrapper">
        <!-- ÎèôÏ†ÅÏúºÎ°ú ÎπÑÎîîÏò§ Ïä¨ÎùºÏù¥ÎìúÍ∞Ä Ï∂îÍ∞ÄÎê©ÎãàÎã§ -->
      </div>
      <div class="swipe-indicators" id="swipe-indicators">
        <!-- Ïù∏ÎîîÏºÄÏù¥ÌÑ∞Í∞Ä ÎèôÏ†ÅÏúºÎ°ú Ï∂îÍ∞ÄÎê©ÎãàÎã§ -->
      </div>
    </div>

    <!-- Ï±ÑÌåÖ Ìå®ÎÑê -->
    <div id="chat-panel">
      <div class="chat-header">
        <span>üí¨ Ï±ÑÌåÖ</span>
        <button class="chat-close" onclick="toggleChat()">√ó</button>
      </div>
      <div id="chat-box"></div>
      <div class="chat-input-wrapper">
        <input type="text" id="chat-input" placeholder="Î©îÏãúÏßÄÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî..." />
        <button onclick="sendChat()">Ï†ÑÏÜ°</button>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/3.0.4/socket.io.js"></script>
    <script>
      // URL ÌååÎùºÎØ∏ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ - Ïù¥ Î∂ÄÎ∂ÑÏù¥ Îπ†Ï†∏ÏûàÏóàÏäµÎãàÎã§!
      const urlParams = new URLSearchParams(location.search);
      const room = urlParams.get("room");
      const nickname = urlParams.get("name");

      if (!room || !nickname) {
        alert("ÏûòÎ™ªÎêú Ï†ëÍ∑ºÏûÖÎãàÎã§.");
        location.href = "/";
      }

      // Ï†ÑÏó≠ Î≥ÄÏàòÎì§ (Í∏∞Ï°¥Í≥º ÎèôÏùºÌïòÍ≤å Ïú†ÏßÄ)
      let myStream = null;
      let myPeerConnection = null;
      let remoteStream = null;
      let isScreenSharing = false;
      let screenTrack = null;
      let cameraEnabled = true;
      let micEnabled = true;
      let isConnected = false;
      let isConnecting = false;
      let pendingCandidates = [];
      let myRole = null;
      let roomParticipants = 0;
      let connectionAttempts = 0;
      const MAX_CONNECTION_ATTEMPTS = 3;

      // Ïä§ÏôÄÏù¥ÌîÑ Í¥ÄÎ†® Î≥ÄÏàò
      let currentSlide = 0;
      let totalSlides = 0;
      let startX = 0;
      let currentX = 0;
      let isDragging = false;

      // ÌÉÄÏù¥Î®∏ Í¥ÄÎ†® Î≥ÄÏàò
      let meetingStartTime;
      let meetingDuration = 2 * 60 * 60 * 1000; // 2ÏãúÍ∞Ñ
      let timerInterval;

      const socket = io();
      const chatBox = document.getElementById("chat-box");
      const chatInput = document.getElementById("chat-input");

      // ÎîîÎ≤ÑÍ∑∏ Ìï®Ïàò
      function updateDebugInfo() {
        document.getElementById('debug-connection').textContent = 
          myPeerConnection ? myPeerConnection.connectionState : 'ÏóÜÏùå';
        document.getElementById('debug-my-stream').textContent = 
          myStream ? `${myStream.getTracks().length}Í∞ú Ìä∏Îûô` : 'ÏóÜÏùå';
        document.getElementById('debug-remote-stream').textContent = 
          remoteStream ? `${remoteStream.getTracks().length}Í∞ú Ìä∏Îûô` : 'ÏóÜÏùå';
        document.getElementById('debug-ice').textContent = 
          myPeerConnection ? myPeerConnection.iceConnectionState : 'ÏóÜÏùå';
        document.getElementById('debug-role').textContent = myRole || 'ÎåÄÍ∏∞Ï§ë';
      }

      // ÏÜåÏºì Ïù¥Î≤§Ìä∏ ÏÑ§Ï†ï
      socket.emit("join", { roomId: room, nickname });

      socket.on("room-full", () => {
        alert("ÏûÖÏû• Ïù∏Ïõê Ï¥àÍ≥º");
        location.href = "/";
      });

      socket.on("room-info", (roomInfo) => {
        console.log("Î∞© Ï†ïÎ≥¥ ÏàòÏã†:", roomInfo);
        meetingStartTime = roomInfo.createdAt;
        roomParticipants = roomInfo.participantCount;
        
        // Ïó≠Ìï† ÏÑ§Ï†ï
        myRole = roomParticipants === 1 ? 'caller' : 'callee';
        console.log(`Ïó≠Ìï† ÏÑ§Ï†ï: ${myRole} (Ï∞∏Ïó¨Ïûê Ïàò: ${roomParticipants})`);
        
        updateDebugInfo();
        startTimer();
      });

      socket.on("user-joined", async (data) => {
        console.log("üöÄ ÏÇ¨Ïö©Ïûê ÏûÖÏû•:", data.nickname);
        updateConnectionStatus("connecting");
        appendChat("ÏãúÏä§ÌÖú", `${data.nickname}ÎãòÏù¥ ÏûÖÏû•ÌñàÏäµÎãàÎã§.`);
        
        // ÏñëÏ™Ω Î™®Îëê ÎØ∏ÎîîÏñ¥Í∞Ä Ï§ÄÎπÑÎêòÏóàÏùÑ ÎïåÎßå Ïó∞Í≤∞ ÏãúÏûë
        if (myStream && !isConnecting && !isConnected) {
          console.log("üîÑ Ïó∞Í≤∞ ÏãúÏûë Ï§ÄÎπÑ...");
          setTimeout(async () => {
            if (myRole === 'caller') {
              console.log("üìû CallerÎ°úÏÑú Ïó∞Í≤∞ ÏãúÏûë");
              await initiateConnection();
            } else {
              console.log("üì± CalleeÎ°úÏÑú Ïó∞Í≤∞ ÎåÄÍ∏∞");
              // CalleeÎäî OfferÎ•º Í∏∞Îã§Î¶º
            }
          }, 1500); // Ï∂©Î∂ÑÌïú ÎåÄÍ∏∞ ÏãúÍ∞Ñ
        }
      });

      socket.on("user-left", (data) => {
        console.log("ÏÇ¨Ïö©Ïûê Ìá¥Ïû•:", data.nickname);
        appendChat("ÏãúÏä§ÌÖú", `${data.nickname}ÎãòÏù¥ Î∞©ÏùÑ ÎÇòÍ∞îÏäµÎãàÎã§.`);
        
        // Ïó∞Í≤∞ Ï†ïÎ¶¨
        cleanupConnection();
        updateVideoSlides();
        updateDebugInfo();
        updateConnectionStatus("connecting");
      });

      socket.on("rtc-message", async (message) => {
        try {
          const content = JSON.parse(message);
          console.log("üì® RTC Î©îÏãúÏßÄ ÏàòÏã†:", content.event, "ÌòÑÏû¨ Ïó≠Ìï†:", myRole);
          
          // PeerConnectionÏù¥ ÏóÜÏúºÎ©¥ ÏÉùÏÑ±
          if (!myPeerConnection) {
            console.log("‚ö†Ô∏è PeerConnectionÏù¥ ÏóÜÏñ¥ÏÑú ÏÉùÏÑ±");
            await createPeerConnection();
          }
          
          switch (content.event) {
            case "offer":
              await handleOffer(content.data);
              break;
            case "answer":
              await handleAnswer(content.data);
              break;
            case "candidate":
              await handleCandidate(content.data);
              break;
          }
        } catch (error) {
          console.error("‚ùå RTC Î©îÏãúÏßÄ Ï≤òÎ¶¨ Ïò§Î•ò:", error);
        }
      });

      socket.on("chat-message", (data) => {
        const { from, message, timestamp } = JSON.parse(data);
        appendChat(from, message, timestamp);
      });

      // WebRTC Ìï®ÏàòÎì§ - ÏôÑÏ†ÑÌûà ÏÉàÎ°ú ÏûëÏÑ±
      async function initializeMedia() {
        try {
          console.log("üé• ÎØ∏ÎîîÏñ¥ Ï¥àÍ∏∞Ìôî ÏãúÏûë...");
          
          // ÎØ∏ÎîîÏñ¥ Í∂åÌïú ÏöîÏ≤≠
          myStream = await navigator.mediaDevices.getUserMedia({
            video: { 
              width: { ideal: 1280 },
              height: { ideal: 720 },
              facingMode: "user"
            },
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true
            }
          });
          
          console.log("‚úÖ ÎØ∏ÎîîÏñ¥ Ïä§Ìä∏Î¶º ÌöçÎìù ÏÑ±Í≥µ:", myStream.getTracks().length, "Í∞ú Ìä∏Îûô");
          
          // Ìä∏Îûô ÏÉÅÌÉú ÌôïÏù∏
          myStream.getTracks().forEach(track => {
            console.log(`üìπ Ìä∏Îûô: ${track.kind}, ÌôúÏÑ±: ${track.enabled}, ÏÉÅÌÉú: ${track.readyState}`);
          });
          
          // UI ÏóÖÎç∞Ïù¥Ìä∏
          updateVideoSlides();
          updateDebugInfo();
          updateConnectionStatus("connected");
          
        } catch (error) {
          console.error("‚ùå ÎØ∏ÎîîÏñ¥ Ï¥àÍ∏∞Ìôî Ïò§Î•ò:", error);
          
          // Ïò§ÎîîÏò§Îßå ÏãúÎèÑ
          try {
            console.log("üé§ Ïò§ÎîîÏò§ÎßåÏúºÎ°ú Ïû¨ÏãúÎèÑ...");
            myStream = await navigator.mediaDevices.getUserMedia({ 
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
              }
            });
            cameraEnabled = false;
            updateCameraButton();
            updateVideoSlides();
            console.log("‚úÖ Ïò§ÎîîÏò§ Ï†ÑÏö© Î™®Îìú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å");
          } catch (audioError) {
            console.error("‚ùå Ïò§ÎîîÏò§ÎèÑ Ïã§Ìå®:", audioError);
            updateConnectionStatus("error");
            alert("Ïπ¥Î©îÎùºÏôÄ ÎßàÏù¥ÌÅ¨ Ï†ëÍ∑ºÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Î∏åÎùºÏö∞Ï†Ä ÏÑ§Ï†ïÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.");
          }
        }
      }

      async function createPeerConnection() {
        console.log("üîó PeerConnection ÏÉùÏÑ± Ï§ë...");
        
        // Í∏∞Ï°¥ Ïó∞Í≤∞ Ï†ïÎ¶¨
        if (myPeerConnection) {
          myPeerConnection.close();
        }
        
        myPeerConnection = new RTCPeerConnection({
          iceServers: [
            { urls: "stun:stun.l.google.com:19302" },
            { urls: "stun:stun1.l.google.com:19302" },
            { urls: "stun:stun2.l.google.com:19302" },
            { urls: "stun:stun3.l.google.com:19302" },
            { urls: "stun:stun4.l.google.com:19302" }
          ],
          iceCandidatePoolSize: 10
        });

        // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
        myPeerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            console.log("üßä ICE candidate Ï†ÑÏÜ°:", event.candidate.type);
            sendSignal("candidate", event.candidate);
          } else {
            console.log("‚úÖ ICE candidate ÏàòÏßë ÏôÑÎ£å");
          }
        };

        // Í∞ÄÏû• Ï§ëÏöîÌïú Î∂ÄÎ∂Ñ: ÏõêÍ≤© Ïä§Ìä∏Î¶º ÏàòÏã†
        myPeerConnection.ontrack = (event) => {
          console.log("üéâ ÏõêÍ≤© Ïä§Ìä∏Î¶º ÏàòÏã†!", event.streams[0]);
          console.log("üì∫ Ìä∏Îûô Ï†ïÎ≥¥:", event.track.kind, event.track.enabled, event.track.readyState);
          
          // ÏõêÍ≤© Ïä§Ìä∏Î¶º ÏÑ§Ï†ï
          remoteStream = event.streams[0];
          isConnected = true;
          isConnecting = false;
          connectionAttempts = 0;
          
          // Ï¶âÏãú UI ÏóÖÎç∞Ïù¥Ìä∏
          updateVideoSlides();
          updateDebugInfo();
          updateConnectionStatus("connected");
          
          // ÏõêÍ≤© Ïä§Ìä∏Î¶º Ìä∏Îûô ÏÉÅÌÉú ÌôïÏù∏
          remoteStream.getTracks().forEach(track => {
            console.log(`üì° ÏõêÍ≤© Ìä∏Îûô: ${track.kind}, ÌôúÏÑ±: ${track.enabled}, ÏÉÅÌÉú: ${track.readyState}`);
            
            // Ìä∏Îûô ÏÉÅÌÉú Î≥ÄÍ≤Ω Í∞êÏßÄ
            track.onended = () => {
              console.log(`‚ö†Ô∏è ÏõêÍ≤© Ìä∏Îûô Ï¢ÖÎ£å: ${track.kind}`);
            };
            
            track.onmute = () => {
              console.log(`üîá ÏõêÍ≤© Ìä∏Îûô ÏùåÏÜåÍ±∞: ${track.kind}`);
            };
            
            track.onunmute = () => {
              console.log(`üîä ÏõêÍ≤© Ìä∏Îûô ÏùåÏÜåÍ±∞ Ìï¥Ï†ú: ${track.kind}`);
            };
          });
        };

        // Ïó∞Í≤∞ ÏÉÅÌÉú Î≥ÄÍ≤Ω
        myPeerConnection.onconnectionstatechange = () => {
          const state = myPeerConnection.connectionState;
          console.log("üîÑ Ïó∞Í≤∞ ÏÉÅÌÉú Î≥ÄÍ≤Ω:", state);
          updateDebugInfo();
          
          switch (state) {
            case 'connected':
              updateConnectionStatus("connected");
              isConnected = true;
              isConnecting = false;
              connectionAttempts = 0;
              console.log("‚úÖ WebRTC Ïó∞Í≤∞ ÏÑ±Í≥µ!");
              break;
            case 'failed':
              updateConnectionStatus("error");
              console.log("‚ùå Ïó∞Í≤∞ Ïã§Ìå®");
              isConnected = false;
              isConnecting = false;
              
              // Ïû¨ÏãúÎèÑ
              if (myRole === 'caller' && connectionAttempts < MAX_CONNECTION_ATTEMPTS) {
                connectionAttempts++;
                console.log(`üîÑ Ïó∞Í≤∞ Ïû¨ÏãúÎèÑ ${connectionAttempts}/${MAX_CONNECTION_ATTEMPTS}`);
                setTimeout(() => {
                  initiateConnection();
                }, 2000 * connectionAttempts);
              }
              break;
            case 'disconnected':
              isConnected = false;
              isConnecting = false;
              updateConnectionStatus("connecting");
              break;
          }
        };

        // ICE Ïó∞Í≤∞ ÏÉÅÌÉú Î≥ÄÍ≤Ω
        myPeerConnection.oniceconnectionstatechange = () => {
          const iceState = myPeerConnection.iceConnectionState;
          console.log("üßä ICE Ïó∞Í≤∞ ÏÉÅÌÉú:", iceState);
          updateDebugInfo();
          
          if (iceState === 'failed') {
            console.log("üîÑ ICE Ïó∞Í≤∞ Ïã§Ìå® - Ïû¨ÏãúÏûë ÏãúÎèÑ");
            myPeerConnection.restartIce();
          }
        };

        // ÏãúÍ∑∏ÎÑêÎßÅ ÏÉÅÌÉú Î≥ÄÍ≤Ω
        myPeerConnection.onsignalingstatechange = () => {
          console.log("üì° ÏãúÍ∑∏ÎÑêÎßÅ ÏÉÅÌÉú:", myPeerConnection.signalingState);
        };

        // Î°úÏª¨ Ïä§Ìä∏Î¶º Ï∂îÍ∞Ä - Îß§Ïö∞ Ï§ëÏöî!
        if (myStream) {
          console.log("üì§ Î°úÏª¨ Ïä§Ìä∏Î¶º Ìä∏Îûô Ï∂îÍ∞Ä Ï§ë...");
          myStream.getTracks().forEach(track => {
            console.log(`‚ûï Ìä∏Îûô Ï∂îÍ∞Ä: ${track.kind}, ÌôúÏÑ±: ${track.enabled}`);
            myPeerConnection.addTrack(track, myStream);
          });
          console.log("‚úÖ Î™®Îì† Î°úÏª¨ Ìä∏Îûô Ï∂îÍ∞Ä ÏôÑÎ£å");
        } else {
          console.warn("‚ö†Ô∏è Î°úÏª¨ Ïä§Ìä∏Î¶ºÏù¥ ÏóÜÏùå!");
        }

        // ÎåÄÍ∏∞ Ï§ëÏù∏ ICE candidates Ï≤òÎ¶¨
        console.log(`üìã ÎåÄÍ∏∞ Ï§ëÏù∏ ICE candidates: ${pendingCandidates.length}Í∞ú`);
        while (pendingCandidates.length > 0) {
          const candidate = pendingCandidates.shift();
          try {
            await myPeerConnection.addIceCandidate(candidate);
            console.log("‚úÖ ÎåÄÍ∏∞ ICE candidate Ï∂îÍ∞ÄÎê®");
          } catch (error) {
            console.error("‚ùå ÎåÄÍ∏∞ ICE candidate Ï∂îÍ∞Ä Ïò§Î•ò:", error);
          }
        }

        updateDebugInfo();
        console.log("‚úÖ PeerConnection ÏÉùÏÑ± ÏôÑÎ£å");
      }

      async function initiateConnection() {
        try {
          if (isConnecting || isConnected) {
            console.log("‚ö†Ô∏è Ïù¥ÎØ∏ Ïó∞Í≤∞ Ï§ëÏù¥Í±∞ÎÇò Ïó∞Í≤∞Îê®");
            return;
          }

          if (!myStream) {
            console.log("‚ö†Ô∏è Î°úÏª¨ Ïä§Ìä∏Î¶ºÏù¥ ÏóÜÏñ¥ÏÑú Ïó∞Í≤∞ ÏãúÏûë Î∂àÍ∞Ä");
            return;
          }

          console.log("üöÄ Ïó∞Í≤∞ ÏãúÏûë...");
          isConnecting = true;
          
          // PeerConnection ÏÉùÏÑ± (ÏïÑÏßÅ ÏóÜÎã§Î©¥)
          if (!myPeerConnection) {
            await createPeerConnection();
          }

          // Sender ÌôïÏù∏
          const senders = myPeerConnection.getSenders();
          console.log(`üì§ ÌòÑÏû¨ Sender Ïàò: ${senders.length}`);
          
          if (senders.length === 0 && myStream) {
            console.log("‚ö†Ô∏è SenderÍ∞Ä ÏóÜÏùå - Ïä§Ìä∏Î¶º Îã§Ïãú Ï∂îÍ∞Ä");
            myStream.getTracks().forEach(track => {
              myPeerConnection.addTrack(track, myStream);
            });
          }

          // Offer ÏÉùÏÑ±
          console.log("üìû Offer ÏÉùÏÑ± Ï§ë...");
          const offer = await myPeerConnection.createOffer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
          });
          
          console.log("üìù LocalDescription ÏÑ§Ï†ï Ï§ë...");
          await myPeerConnection.setLocalDescription(offer);
          
          console.log("üì® Offer Ï†ÑÏÜ°");
          sendSignal("offer", offer);
          
        } catch (error) {
          console.error("‚ùå Ïó∞Í≤∞ ÏãúÏûë Ïò§Î•ò:", error);
          isConnecting = false;
        }
      }

      async function handleOffer(offer) {
        try {
          console.log("üìû Offer ÏàòÏã† Ï≤òÎ¶¨ Ï§ë...");
          
          if (myRole === 'caller') {
            console.log("‚ö†Ô∏è CallerÍ∞Ä OfferÎ•º Î∞õÏùå - Î¨¥Ïãú");
            return;
          }

          if (isConnecting || isConnected) {
            console.log("‚ö†Ô∏è Ïù¥ÎØ∏ Ïó∞Í≤∞ Ï§ëÏù¥Í±∞ÎÇò Ïó∞Í≤∞Îê® - Offer Î¨¥Ïãú");
            return;
          }

          isConnecting = true;
          
          // PeerConnection ÏÉùÏÑ± (ÏïÑÏßÅ ÏóÜÎã§Î©¥)
          if (!myPeerConnection) {
            await createPeerConnection();
          }
          
          console.log("üìù RemoteDescription ÏÑ§Ï†ï Ï§ë...");
          await myPeerConnection.setRemoteDescription(offer);
          
          // Sender ÌôïÏù∏ Î∞è Ï∂îÍ∞Ä
          const senders = myPeerConnection.getSenders();
          console.log(`üì§ Answer ÏÉùÏÑ± Ï†Ñ Sender Ïàò: ${senders.length}`);
          
          if (senders.length === 0 && myStream) {
            console.log("‚ö†Ô∏è Ïä§Ìä∏Î¶ºÏù¥ Ï∂îÍ∞ÄÎêòÏßÄ ÏïäÏùå - Îã§Ïãú Ï∂îÍ∞Ä");
            myStream.getTracks().forEach(track => {
              myPeerConnection.addTrack(track, myStream);
            });
          }
          
          console.log("üì± Answer ÏÉùÏÑ± Ï§ë...");
          const answer = await myPeerConnection.createAnswer();
          
          console.log("üìù LocalDescription(Answer) ÏÑ§Ï†ï Ï§ë...");
          await myPeerConnection.setLocalDescription(answer);
          
          console.log("üì® Answer Ï†ÑÏÜ°");
          sendSignal("answer", answer);
          
        } catch (error) {
          console.error("‚ùå Offer Ï≤òÎ¶¨ Ïò§Î•ò:", error);
          isConnecting = false;
        }
      }

      async function handleAnswer(answer) {
        try {
          console.log("üì± Answer ÏàòÏã† Ï≤òÎ¶¨ Ï§ë...");
          
          if (myRole === 'callee') {
            console.log("‚ö†Ô∏è CalleeÍ∞Ä AnswerÎ•º Î∞õÏùå - Î¨¥Ïãú");
            return;
          }
          
          if (myPeerConnection.signalingState === "have-local-offer") {
            console.log("üìù RemoteDescription(Answer) ÏÑ§Ï†ï Ï§ë...");
            await myPeerConnection.setRemoteDescription(answer);
            console.log("‚úÖ Answer Ï≤òÎ¶¨ ÏôÑÎ£å");
          } else {
            console.log("‚ö†Ô∏è Answer Î¨¥Ïãú - ÏûòÎ™ªÎêú ÏÉÅÌÉú:", myPeerConnection.signalingState);
          }
        } catch (error) {
          console.error("‚ùå Answer Ï≤òÎ¶¨ Ïò§Î•ò:", error);
          isConnecting = false;
        }
      }

      async function handleCandidate(candidate) {
        try {
          if (candidate && myPeerConnection) {
            if (myPeerConnection.remoteDescription) {
              console.log("üßä ICE candidate Ï∂îÍ∞Ä:", candidate.type);
              await myPeerConnection.addIceCandidate(candidate);
            } else {
              console.log("üìã ICE candidate ÎåÄÍ∏∞ Ï§ë (remoteDescription ÏóÜÏùå)");
              pendingCandidates.push(candidate);
            }
        }
      } catch (error) {
        console.error("‚ùå ICE candidate Ï≤òÎ¶¨ Ïò§Î•ò:", error);
      }
    }

    function cleanupConnection() {
      console.log("üßπ Ïó∞Í≤∞ Ï†ïÎ¶¨ Ï§ë...");
      
      // ÏõêÍ≤© Ïä§Ìä∏Î¶º Ï†ïÎ¶¨
      if (remoteStream) {
        remoteStream.getTracks().forEach(track => track.stop());
        remoteStream = null;
      }
      
      // Ïó∞Í≤∞ Ï†ïÎ¶¨
      if (myPeerConnection) {
        myPeerConnection.close();
        myPeerConnection = null;
      }
      
      isConnected = false;
      isConnecting = false;
      pendingCandidates = [];
      connectionAttempts = 0;
      
      console.log("‚úÖ Ïó∞Í≤∞ Ï†ïÎ¶¨ ÏôÑÎ£å");
    }

    function sendSignal(event, data) {
      const message = JSON.stringify({ 
        roomId: room, 
        event, 
        data 
      });
      console.log(`üì° ÏãúÍ∑∏ÎÑê Ï†ÑÏÜ°: ${event} (ÌÅ¨Í∏∞: ${message.length})`);
      socket.emit("rtc-message", message);
    }

function updateVideoSlides() {
  const swipeWrapper = document.getElementById('swipe-wrapper');
  const indicators = document.getElementById('swipe-indicators');
  
  swipeWrapper.innerHTML = '';
  indicators.innerHTML = '';
  
  const slides = [];
  
  // ÎÇ¥ ÎπÑÎîîÏò§ Ïä¨ÎùºÏù¥Îìú
  if (myStream) {
    slides.push({
      stream: myStream,
      nickname: `${nickname} (ÎÇò)`,
      isMe: true
    });
  }
  
  // ÏÉÅÎåÄÎ∞© ÎπÑÎîîÏò§ Ïä¨ÎùºÏù¥Îìú
  if (remoteStream) {
    slides.push({
      stream: remoteStream,
      nickname: "ÏÉÅÎåÄÎ∞©",
      isMe: false
    });
  }
  
  // Îπà Ïä¨ÎùºÏù¥Îìú (Ïó∞Í≤∞ ÎåÄÍ∏∞ Ï§ë)
  if (!remoteStream) {
    slides.push({
      stream: null,
      nickname: isConnected ? "Ïó∞Í≤∞Îê®" : "ÏÉÅÎåÄÎ∞© ÎåÄÍ∏∞ Ï§ë",
      isEmpty: true
    });
  }
  
  totalSlides = slides.length;
  console.log(`üé¨ ÎπÑÎîîÏò§ Ïä¨ÎùºÏù¥Îìú ÏóÖÎç∞Ïù¥Ìä∏: ${slides.length}Í∞ú (ÎÇ¥ Ïä§Ìä∏Î¶º: ${!!myStream}, ÏõêÍ≤© Ïä§Ìä∏Î¶º: ${!!remoteStream})`);
  
  slides.forEach((slide, index) => {
    const slideElement = document.createElement('div');
    slideElement.className = slide.isEmpty ? 'video-slide empty' : 'video-slide';
    
    if (!slide.isEmpty) {
      const video = document.createElement('video');
      
      // ÎπÑÎîîÏò§ ÏÜçÏÑ± ÏÑ§Ï†ï
      video.autoplay = true;
      video.playsInline = true;
      video.controls = false;
      video.style.width = '100%';
      video.style.height = '100%';
      video.style.objectFit = 'cover';
      video.style.backgroundColor = '#000';
      
      if (slide.isMe) {
        video.muted = true;
        video.style.transform = 'scaleX(-1)'; // ÏÖÄÏπ¥ Î™®Îìú
      } else {
        video.muted = false; // ÏÉÅÎåÄÎ∞© ÏÜåÎ¶¨Îäî Îì§Ïñ¥Ïïº Ìï®
      }
      
      console.log(`üé• ÎπÑÎîîÏò§ ÏöîÏÜå ÏÉùÏÑ±: ${slide.nickname}`, slide.stream);
      
      // Ïä§Ìä∏Î¶º Ïó∞Í≤∞
      video.srcObject = slide.stream;
      
      // ÎπÑÎîîÏò§ Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑàÎì§
      video.onloadedmetadata = () => {
        console.log(`‚úÖ ÎπÑÎîîÏò§ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î°úÎìú: ${slide.nickname}`, {
          videoWidth: video.videoWidth,
          videoHeight: video.videoHeight,
          duration: video.duration
        });
        
        // ÏûêÎèô Ïû¨ÏÉù ÏãúÎèÑ
        video.play()
          .then(() => {
            console.log(`‚ñ∂Ô∏è ÎπÑÎîîÏò§ Ïû¨ÏÉù ÏÑ±Í≥µ: ${slide.nickname}`);
          })
          .catch(e => {
            console.error(`‚ùå ÎπÑÎîîÏò§ Ïû¨ÏÉù Ïò§Î•ò: ${slide.nickname}`, e);
            
            // ÏàòÎèô Ïû¨ÏÉù Î≤ÑÌäº Ï∂îÍ∞Ä
            const playButton = document.createElement('button');
            playButton.textContent = '‚ñ∂Ô∏è Ïû¨ÏÉù';
            playButton.style.position = 'absolute';
            playButton.style.top = '50%';
            playButton.style.left = '50%';
            playButton.style.transform = 'translate(-50%, -50%)';
            playButton.style.zIndex = '1000';
            playButton.style.padding = '10px 20px';
            playButton.style.backgroundColor = 'rgba(0,0,0,0.7)';
            playButton.style.color = 'white';
            playButton.style.border = 'none';
            playButton.style.borderRadius = '5px';
            playButton.style.cursor = 'pointer';
            
            playButton.onclick = () => {
              video.play()
                .then(() => {
                  slideElement.removeChild(playButton);
                  console.log(`‚úÖ ÏàòÎèô Ïû¨ÏÉù ÏÑ±Í≥µ: ${slide.nickname}`);
                })
                .catch(err => console.error(`‚ùå ÏàòÎèô Ïû¨ÏÉù Ïã§Ìå®: ${slide.nickname}`, err));
            };
            
            slideElement.appendChild(playButton);
          });
      };
      
      video.onerror = (e) => {
        console.error(`‚ùå ÎπÑÎîîÏò§ Ïò§Î•ò: ${slide.nickname}`, e);
      };
      
      video.onplay = () => {
        console.log(`‚ñ∂Ô∏è ÎπÑÎîîÏò§ Ïû¨ÏÉù ÏãúÏûë: ${slide.nickname}`);
      };
      
      video.onpause = () => {
        console.log(`‚è∏Ô∏è ÎπÑÎîîÏò§ ÏùºÏãúÏ†ïÏßÄ: ${slide.nickname}`);
      };
      
      const nicknameLabel = document.createElement('div');
      nicknameLabel.className = 'nickname-label';
      nicknameLabel.textContent = slide.nickname;
      
      slideElement.appendChild(video);
      slideElement.appendChild(nicknameLabel);
    } else {
      const emptyText = document.createElement('div');
      emptyText.textContent = slide.nickname;
      emptyText.style.display = 'flex';
      emptyText.style.alignItems = 'center';
      emptyText.style.justifyContent = 'center';
      emptyText.style.height = '100%';
      emptyText.style.fontSize = '18px';
      emptyText.style.color = '#666';
      slideElement.appendChild(emptyText);
    }
    
    swipeWrapper.appendChild(slideElement);
    
    // Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ Ï∂îÍ∞Ä
    const dot = document.createElement('div');
    dot.className = `swipe-dot ${index === currentSlide ? 'active' : ''}`;
    dot.addEventListener('click', () => goToSlide(index));
    indicators.appendChild(dot);
  });
  
  // ÌòÑÏû¨ Ïä¨ÎùºÏù¥Îìú Ï°∞Ï†ï
  if (currentSlide >= totalSlides) {
    currentSlide = Math.max(0, totalSlides - 1);
  }
  
  goToSlide(currentSlide);
  
  // Î†àÏù¥ÏïÑÏõÉ ÌÅ¥ÎûòÏä§ Ï†ÅÏö©
  applyLayoutClass();
}

      function updateConnectionStatus(status) {
        const statusElement = document.getElementById('connection-status');
        const statusMap = {
          connecting: { text: "üì° Ïó∞Í≤∞ Ï§ë...", class: "status-connecting" },
          connected: { text: "‚úÖ Ïó∞Í≤∞Îê®", class: "status-connected" },
          error: { text: "‚ùå Ïó∞Í≤∞ Ïã§Ìå®", class: "status-error" }
        };
        
        const statusInfo = statusMap[status] || statusMap.connecting;
        statusElement.innerHTML = `<div class="${statusInfo.class}">${statusInfo.text}</div>`;
      }

      // Ïª®Ìä∏Î°§ Ìï®ÏàòÎì§
      async function toggleCamera() {
        if (!myStream) return;
        
        const videoTrack = myStream.getVideoTracks()[0];
        if (videoTrack) {
          cameraEnabled = !cameraEnabled;
          videoTrack.enabled = cameraEnabled;
          updateCameraButton();
          console.log("Ïπ¥Î©îÎùº ÏÉÅÌÉú:", cameraEnabled);
        }
      }

      function updateCameraButton() {
        const button = document.getElementById("toggle-camera");
        if (cameraEnabled) {
          button.textContent = "üì∑";
          button.classList.add("active");
        } else {
          button.textContent = "üì∑";
          button.classList.remove("active");
        }
      }

      async function toggleMic() {
        if (!myStream) return;
        
        const audioTrack = myStream.getAudioTracks()[0];
        if (audioTrack) {
          micEnabled = !micEnabled;
          audioTrack.enabled = micEnabled;
          updateMicButton();
          console.log("ÎßàÏù¥ÌÅ¨ ÏÉÅÌÉú:", micEnabled);
        }
      }

      function updateMicButton() {
        const button = document.getElementById("toggle-mic");
        if (micEnabled) {
          button.textContent = "üé§";
          button.classList.add("active");
        } else {
          button.textContent = "üé§";
          button.classList.remove("active");
        }
      }

      async function toggleScreenShare() {
        const button = document.getElementById("screen-share-btn");
        
        if (!isScreenSharing) {
          try {
            console.log("ÌôîÎ©¥ Í≥µÏú† ÏãúÏûë...");
            const screenStream = await navigator.mediaDevices.getDisplayMedia({ 
              video: true,
              audio: true 
            });
            
            screenTrack = screenStream.getVideoTracks()[0];
            
            // WebRTC Ïó∞Í≤∞ÏóêÏÑú ÎπÑÎîîÏò§ Ìä∏Îûô ÍµêÏ≤¥
            if (myPeerConnection) {
              const sender = myPeerConnection.getSenders().find(s => 
                s.track && s.track.kind === "video"
              );
              if (sender) {
                await sender.replaceTrack(screenTrack);
                console.log("ÌôîÎ©¥ Í≥µÏú† Ìä∏Îûô ÍµêÏ≤¥ ÏôÑÎ£å");
              }
            }
            
            // Î°úÏª¨ Ïä§Ìä∏Î¶º ÏóÖÎç∞Ïù¥Ìä∏
            const newStream = new MediaStream([
              screenTrack,
              ...myStream.getAudioTracks()
            ]);
            myStream = newStream;
            
            // ÌôîÎ©¥ Í≥µÏú† Ï¢ÖÎ£å Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨
            screenTrack.onended = () => {
              console.log("ÌôîÎ©¥ Í≥µÏú† Ï¢ÖÎ£åÎê®");
              stopScreenShare();
            };
            
            isScreenSharing = true;
            button.textContent = "üñ•Ô∏è Í≥µÏú†Ï§ë";
            button.classList.add("active");
            
            updateVideoSlides();
            
          } catch (error) {
            console.error("ÌôîÎ©¥ Í≥µÏú† Ïò§Î•ò:", error);
            alert("ÌôîÎ©¥ Í≥µÏú†Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: " + error.message);
          }
        } else {
          stopScreenShare();
        }
      }

      async function stopScreenShare() {
        if (!isScreenSharing) return;
        
        try {
          console.log("ÌôîÎ©¥ Í≥µÏú† Ï§ëÏßÄ...");
          
          // ÏõêÎûò Ïπ¥Î©îÎùºÎ°ú Î≥µÏõê
          const cameraStream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true
          });
          
          // WebRTC Ïó∞Í≤∞ÏóêÏÑú Ìä∏Îûô ÍµêÏ≤¥
          if (myPeerConnection) {
            const sender = myPeerConnection.getSenders().find(s => 
              s.track && s.track.kind === "video"
            );
            if (sender) {
              await sender.replaceTrack(cameraStream.getVideoTracks()[0]);
            }
          }
          
          // ÌôîÎ©¥ Í≥µÏú† Ìä∏Îûô Ï†ïÎ¶¨
          if (screenTrack) {
            screenTrack.stop();
            screenTrack = null;
          }
          
          myStream = cameraStream;
          isScreenSharing = false;
          
          const button = document.getElementById("screen-share-btn");
          button.textContent = "üñ•Ô∏è";
          button.classList.remove("active");
          
          updateVideoSlides();
          
        } catch (error) {
          console.error("ÌôîÎ©¥ Í≥µÏú† Ï§ëÏßÄ Ïò§Î•ò:", error);
        }
      }

      // Ïä§ÏôÄÏù¥ÌîÑ Í∏∞Îä• (ÌòÑÏû¨Îäî ÎπÑÌôúÏÑ±Ìôî)
      function initSwipeEvents() {
        // Ïä§ÏôÄÏù¥ÌîÑ Í∏∞Îä•ÏùÄ ÌòÑÏû¨ Î†àÏù¥ÏïÑÏõÉÏóêÏÑú ÎπÑÌôúÏÑ±Ìôî
        console.log("Ïä§ÏôÄÏù¥ÌîÑ Ïù¥Î≤§Ìä∏ Ï¥àÍ∏∞Ìôî (ÎπÑÌôúÏÑ±ÌôîÎê®)");
      }

      function goToSlide(index) {
        currentSlide = Math.max(0, Math.min(index, totalSlides - 1));
        // Ïä§ÏôÄÏù¥ÌîÑ Í∏∞Îä• ÎπÑÌôúÏÑ±ÌôîÎ°ú Ïù∏Ìï¥ Ïã§Ï†ú Ïä¨ÎùºÏù¥Îìú Ïù¥Îèô ÏóÜÏùå
      }

      // Ï±ÑÌåÖ Ìï®ÏàòÎì§
      function sendChat() {
        const msg = chatInput.value.trim();
        if (!msg) return;
        
        const now = Date.now();
        socket.emit("chat-message", JSON.stringify({ 
          roomId: room, 
          from: nickname, 
          message: msg, 
          timestamp: now 
        }));
        appendChat(nickname, msg, now);
        chatInput.value = "";
      }

      function appendChat(who, msg, time = null) {
        const p = document.createElement("p");
        const now = time ? new Date(time) : new Date();
        const hhmm = now.toLocaleTimeString("ko-KR", { 
          hour: "2-digit", 
          minute: "2-digit", 
          hour12: false 
        });
        p.textContent = `[${hhmm}] ${who}: ${msg}`;
        chatBox.appendChild(p);
        chatBox.scrollTop = chatBox.scrollHeight;
      }

      function toggleChat() {
        document.getElementById("chat-panel").classList.toggle("open");
      }

      // Î†àÏù¥ÏïÑÏõÉ Ïä§ÌÅ¨Î¶ΩÌä∏
      function applyLayoutClass() {
        const videoSlides = document.querySelectorAll('.video-slide');
        const count = videoSlides.length;
        const swipeWrapper = document.querySelector('.swipe-wrapper');
        if (!swipeWrapper) return;
        
        // Í∏∞Ï°¥ layout ÌÅ¥ÎûòÏä§ Ï†úÍ±∞
        swipeWrapper.className = swipeWrapper.className
          .split(' ')
          .filter(c => !/^layout-\d+$/.test(c))
          .join(' ');
        
        // ÏÉà layout ÌÅ¥ÎûòÏä§ Ï∂îÍ∞Ä
        swipeWrapper.classList.add('layout-' + count);
        console.log("Î†àÏù¥ÏïÑÏõÉ ÌÅ¥ÎûòÏä§ Ï†ÅÏö©:", 'layout-' + count);
      }

      // ÌÉÄÏù¥Î®∏ Ìï®ÏàòÎì§
      function startTimer() {
        if (!meetingStartTime) {
          meetingStartTime = Date.now();
        }
        
        updateTimer();
        timerInterval = setInterval(updateTimer, 1000);
      }

      function updateTimer() {
        const currentTime = Date.now();
        const elapsedTime = currentTime - meetingStartTime;
        const remainingTime = meetingDuration - elapsedTime;
        
        const timerDisplay = document.getElementById('timer-display');
        const timerContainer = document.getElementById('timer-container');
        
        if (remainingTime <= 0) {
          timerDisplay.textContent = 'ÏãúÍ∞Ñ Ï¢ÖÎ£å';
          timerContainer.classList.add('timer-danger');
          clearInterval(timerInterval);
          
          setTimeout(() => {
            alert('ÌöåÏùò ÏãúÍ∞ÑÏù¥ Ï¢ÖÎ£åÎêòÏñ¥ Î∞©ÏóêÏÑú ÎÇòÍ∞ëÎãàÎã§.');
            leaveRoom();
          }, 3000);
          return;
        }
        
        const hours = Math.floor(remainingTime / (60 * 60 * 1000));
        const minutes = Math.floor((remainingTime % (60 * 60 * 1000)) / (60 * 1000));
        
        timerDisplay.textContent = `ÌöåÏùò ÏãúÍ∞Ñ: ${hours}ÏãúÍ∞Ñ ${minutes.toString().padStart(2, '0')}Î∂Ñ`;
        
        if (remainingTime <= 30 * 60 * 1000) {
          timerContainer.classList.add('timer-warning');
        }
        
        if (remainingTime <= 5 * 60 * 1000) {
          timerContainer.classList.remove('timer-warning');
          timerContainer.classList.add('timer-danger');
        }
      }

      function leaveRoom() {
        if (timerInterval) {
          clearInterval(timerInterval);
        }
        
        if (myStream) {
          myStream.getTracks().forEach(track => track.stop());
        }
        
        cleanupConnection();
        
        socket.disconnect();
        location.href = "/";
      }

      // ÎîîÎ≤ÑÍπÖÏùÑ ÏúÑÌïú Ìï®Ïàò
      function debugConnectionState() {
        console.log("=== Ïó∞Í≤∞ ÏÉÅÌÉú ÎîîÎ≤ÑÍ∑∏ ===");
        console.log("ÎÇ¥ Ïó≠Ìï†:", myRole);
        console.log("Ïó∞Í≤∞ Ï§ë:", isConnecting);
        console.log("Ïó∞Í≤∞Îê®:", isConnected);
        console.log("Ïó∞Í≤∞ ÏãúÎèÑ ÌöüÏàò:", connectionAttempts);
        console.log("PeerConnection ÏÉÅÌÉú:", myPeerConnection?.connectionState);
        console.log("ICE ÏÉÅÌÉú:", myPeerConnection?.iceConnectionState);
        console.log("ÏãúÍ∑∏ÎÑêÎßÅ ÏÉÅÌÉú:", myPeerConnection?.signalingState);
        
        if (myPeerConnection) {
          const senders = myPeerConnection.getSenders();
          console.log("Senders:", senders.length);
          senders.forEach((sender, i) => {
            console.log(`Sender ${i}:`, sender.track?.kind || 'null');
          });
          
          const receivers = myPeerConnection.getReceivers();
          console.log("Receivers:", receivers.length);
          receivers.forEach((receiver, i) => {
            console.log(`Receiver ${i}:`, receiver.track?.kind || 'null');
          });
        }
        
        console.log("ÎÇ¥ Ïä§Ìä∏Î¶º Ìä∏Îûô:", myStream?.getTracks().length || 0);
        console.log("ÏõêÍ≤© Ïä§Ìä∏Î¶º Ìä∏Îûô:", remoteStream?.getTracks().length || 0);
        console.log("========================");
      }

      // Ï¥àÍ∏∞Ìôî
      async function initialize() {
        console.log("Ïï± Ï¥àÍ∏∞Ìôî ÏãúÏûë...");
        
        document.getElementById("title").textContent = `Î∞©: ${room} | ${nickname}`;
        
        // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
        chatInput.addEventListener("keyup", (e) => {
          if (e.key === "Enter") sendChat();
        });
        
        // Ïä§ÏôÄÏù¥ÌîÑ Ïù¥Î≤§Ìä∏ Ï¥àÍ∏∞Ìôî (ÎπÑÌôúÏÑ±Ìôî)
        initSwipeEvents();
        
        // ÎØ∏ÎîîÏñ¥ Ï¥àÍ∏∞Ìôî
        await initializeMedia();
        
        // ÎîîÎ≤ÑÍ∑∏ Ï†ïÎ≥¥ Ï£ºÍ∏∞Ï†Å ÏóÖÎç∞Ïù¥Ìä∏
        setInterval(updateDebugInfo, 2000);
        
        // Î†àÏù¥ÏïÑÏõÉ ÌÅ¥ÎûòÏä§ Ï£ºÍ∏∞Ï†Å Ï†ÅÏö©
        setInterval(applyLayoutClass, 3000);
        
        // Ïó∞Í≤∞ ÏÉÅÌÉú ÎîîÎ≤ÑÍπÖ (Í∞úÎ∞úÏö©)
        setInterval(debugConnectionState, 15000);
        
        console.log("Ï¥àÍ∏∞Ìôî ÏôÑÎ£å");
      }

      // Ïï± ÏãúÏûë
      initialize().catch(error => {
        console.error("Ï¥àÍ∏∞Ìôî Ïò§Î•ò:", error);
        updateConnectionStatus("error");
      });
    </script>
</body>
</html>
