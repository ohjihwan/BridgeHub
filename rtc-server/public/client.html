<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>WebRTC í™”ë©´ê³µìœ </title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      * {
        margin:0;
        padding:0;
        box-sizing: border-box;
      }
      html {font-size:16px;}
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        margin: 0;
        padding-top:50px;
        background: #fff;
        min-height: 100vh;
        color: #333333;
        background-color:#333;
      }
      
      .header {
        position:fixed;
        left:0;
        top:0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        width:100%;
        height:50px;
        margin-bottom: 24px;
        flex-wrap: wrap;
        gap: 16px;
      }
      
      h1#title {
        position:fixed;
        left:0;
        top:5px;
        padding:0 16px;
        color: #fff;
        height:40px;
        font-size: 14px;
        font-weight: 600;
        margin: 0;
        width:calc(100% - 180px);
        text-align:left;
        word-break:keep-all;
        display:-webkit-box;
        -webkit-line-clamp:2;
        -webkit-box-orient:vertical;
        overflow:hidden;
        text-overflow:ellipsis;
        overflow:hidden;
      }
      
      .timer-container {
        position:fixed;
        right:0;
        top:0;
        background: rgba(102, 126, 234, 0.1);
        border: 1px solid rgba(102, 126, 234, 0.2);
        border-radius:0 0 0 12px;
        height:50px;
        padding: 3px 0;
        display: flex;
        justify-content:center;
        width: 180px;
        color: #667eea;
        text-wrap:nowrap;
      }
      
      .timer-icon {
        font-size: 1.1rem;
      }
      
      .timer-text {
        font-weight: 600;
        font-size: 13px;
      }
      
      .timer-warning {
        background: rgba(255, 193, 7, 0.1);
        border-color: rgba(255, 193, 7, 0.3);
        color: #ffc107;
      }
      
      .timer-danger {
        background: rgba(220, 53, 69, 0.1);
        border-color: rgba(220, 53, 69, 0.3);
        color: #dc3545;
        animation: pulse-danger 1s infinite;
      }
      
      @keyframes pulse-danger {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
      }
      
      .controls {
        position:fixed;
        left:50%;
        bottom:24px;
        transform:translateX(-50%);
        z-index:100;
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 8px;
        width:100%;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      }
      
      .controls button {
        display:flex;
        justify-content:center;
        align-items:center;
        width:48px;
        height:48px;
        border: 1px solid #e1e5e9;
        border-radius: 50%;
        font-size: 24px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        background: #ffffff;
        color: #333333;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      }

      #toggle-camera{
        padding-bottom:8px;
      }
      
      .controls button:hover {
        background: #f8f9fa;
        border-color: #007fff;
        transform: translateY(-1px);
      }
      
      .controls button.active {
        background-color: #007fff;
        color: #fff;
        border-color: #007fff;
      }
      
      .controls button.danger {
        background: #dc3545;
        color: #fff;
        border-color: #dc3545;
      }
      
      .controls button.danger:hover {
        background: #c82333;
      }
      
      /* ëª¨ë°”ì¼ ìŠ¤ì™€ì´í”„ ì»¨í…Œì´ë„ˆ */
      .mobile-container {
        display:flex;
        position: relative;
        overflow: hidden;
        height:calc(100vh - 150px);
      }
      
      .swipe-wrapper {
        display: flex !important;
        gap:10px !important;
        flex-wrap:wrap;
        transition: all 0.3s ease;
        transform: translateX(0) !important;
        width: 100%;
        padding-top:15px;
      }

      .swipe-wrapper.layout-1 .video-slide {width:100%;}
      .swipe-wrapper.layout-2 {flex-direction:column;}
      .swipe-wrapper.layout-2 .video-slide {width:100%;}
      .swipe-wrapper.layout-3 {justify-content:center;}
      .swipe-wrapper.layout-5 {justify-content:center;}
      .swipe-wrapper.layout-7 {justify-content:center;}
      .swipe-wrapper.layout-9 {justify-content:center;}
      
      .video-slide {
        overflow:hidden;
        width:calc(50% - 5px);
        position: relative;
        background: #222;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius:10px;;
      }
      
      .video-slide video {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      
      .video-slide.empty {
        background: #222;
        color: #888;
        font-size: 1.2rem;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        border-radius:10px;;
      }
      
      .video-slide.empty::before {
        content: "ğŸ‘¤";
        font-size: 3rem;
        opacity: 0.3;
        margin-bottom: 10px;
      }
      
      .nickname-label {
        position: absolute;
        bottom: 6px;
        left: 6px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 6px 6px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        z-index: 10;
      }
      
      .swipe-indicators {
        display: none;
        justify-content: center;
        gap: 8px;
        padding: 16px;
        background: rgba(255, 255, 255, 0.9);
      }
      
      .swipe-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #cccccc;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      
      .swipe-dot.active {
        background: #667eea;
        transform: scale(1.3);
      }
      
      .connection-status {
        text-align: left;
      }

      [class^="status"] {
        position:fixed;
        right:17px;
        top:23px;
      }
      
      .status-connecting {
        color: #ffc107;
      }
      
      .status-connected {
        color: #28a745;
      }
      
      .status-error {
        color: #dc3545;
      }
      
      /* ì±„íŒ… íŒ¨ë„ */
      #chat-panel {
        position: fixed;
        top: 0;
        right: -300px;
        width: 280px;
        height: 100%;
        background: #36393f;
        border-left: 1px solid #40444b;
        box-shadow: -4px 0 6px -1px rgb(0 0 0 / 0.3);
        transition: right 0.3s ease;
        display: flex;
        flex-direction: column;
        z-index: 999;
      }
      
      #chat-panel.open {
        right: 0;
      }
      
      .chat-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px;
        background: #2f3136;
        border-bottom: 1px solid #40444b;
        color: #ffffff;
        font-weight: 600;
        font-size: 16px;
      }
      
      .chat-close {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
        width: 32px;
        height: 32px;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }
      
      .chat-close:hover {
        background: rgba(255, 255, 255, 0.2);
      }
      
      #chat-box {
        flex: 1;
        padding: 20px;
        overflow-y: auto;
        background: #36393f;
        font-size: 14px;
        line-height: 1.5;
      }
      
      #chat-box p {
        margin: 8px 0;
        padding: 12px 16px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: #dcddde;
      }
      
      .chat-input-wrapper {
        display: flex;
        border-top: 1px solid #40444b;
        background: #2f3136;
      }
      
      #chat-input {
        flex: 1;
        padding: 16px;
        border: none;
        background: transparent;
        font-size: 14px;
        outline: none;
        color: #dcddde;
      }
      
      #chat-input::placeholder {
        color: #72767d;
      }
      
      .chat-input-wrapper button {
        padding: 16px 20px;
        border: none;
        background: #5865f2;
        color: white;
        cursor: pointer;
        font-weight: 500;
        font-size: 14px;
        transition: all 0.2s ease;
      }
      
      .chat-input-wrapper button:hover {
        background: #007fff;
      }
      
      /* ë””ë²„ê·¸ ì •ë³´ */
      .debug-info {
        position: fixed;
        bottom:0;
        left:0;
        color: #fff;
        font-size: 15px;
        padding-right:7px;
        z-index: 1000;
        border-radius:0 10px 0 0;
        background-color:rgba(0, 0, 0, 0.7);
        
		white-space:nowrap;
		text-overflow:hidden;
		text-overflow:ellipsis;
      }

      .debug-info div {
        display:inline-block;
        font-size:12px;
      }

      .debug-info div::after {
        content:' / ';
      }
      .debug-info div:last-child::after {
        display: none;
      }
      
      /* ëª¨ë°”ì¼ ìµœì í™” */
     /*  @media (max-width: 768px) {
        body {
          padding: 12px;
        }
        
        .header {
          flex-direction: column;
          text-align: center;
          padding: 16px;
          background-color:#333;
        }
        
        h1 {
          font-size: 1.3rem;
          margin-bottom: 12px;
        }
        
        .timer-container {
          order: -1;
          margin-bottom: 12px;
          min-width: auto;
        }
        
        .controls {
          padding: 16px;
          gap: 6px;
        }
        
        .controls button {
          padding: 10px 12px;
          font-size: 12px;
          min-width: 70px;
        }
        
        #chat-panel {
          width: 90%;
          right: -90%;
        }
        
        .debug-info {
          position: relative;
          margin-bottom: 20px;
        }
      } */
    </style>
  </head>
  <body>
    <!-- ë””ë²„ê·¸ ì •ë³´ -->
    <div class="debug-info" id="debug-info">
      <div>ì—°ê²° ìƒíƒœ: <span id="debug-connection">ì´ˆê¸°í™” ì¤‘</span></div>
      <div>ë‚´ ìŠ¤íŠ¸ë¦¼: <span id="debug-my-stream">ì—†ìŒ</span></div>
      <div>ìƒëŒ€ ìŠ¤íŠ¸ë¦¼: <span id="debug-remote-stream">ì—†ìŒ</span></div>
      <div>ICE ìƒíƒœ: <span id="debug-ice">ì—†ìŒ</span></div>
    </div>

    <div class="header">
      <h1 id="title">ì—°ê²° ì¤‘...</h1>
      <div class="timer-container" id="timer-container">
        <span class="timer-icon">â°</span>
        <span class="timer-text" id="timer-display">íšŒì˜ ì‹œê°„: 2ì‹œê°„ 00ë¶„</span>
      </div>
    </div>
    
    <div class="controls">
      <button id="toggle-camera" onclick="toggleCamera()" class="active">ğŸ“·</button>
      <button id="toggle-mic" onclick="toggleMic()" class="active">ğŸ¤</button>
      <button id="screen-share-btn" onclick="toggleScreenShare()">ğŸ–¥ï¸</button>
      <button onclick="toggleChat()">ğŸ’¬</button>
      <button onclick="leaveRoom()" class="danger">ğŸšª</button>
    </div>
    
    <div class="connection-status" id="connection-status">
      <div class="status-connecting">ğŸ“¡ ì—°ê²° ì¤‘...</div>
    </div>
    
    <!-- ëª¨ë°”ì¼ ìŠ¤ì™€ì´í”„ ì»¨í…Œì´ë„ˆ -->
    <div class="mobile-container">
      <div class="swipe-wrapper" id="swipe-wrapper">
        <!-- ë™ì ìœ¼ë¡œ ë¹„ë””ì˜¤ ìŠ¬ë¼ì´ë“œê°€ ì¶”ê°€ë©ë‹ˆë‹¤ -->
      </div>
      <div class="swipe-indicators" id="swipe-indicators">
        <!-- ì¸ë””ì¼€ì´í„°ê°€ ë™ì ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤ -->
      </div>
    </div>

    <!-- ì±„íŒ… íŒ¨ë„ -->
    <div id="chat-panel">
      <div class="chat-header">
        <span>ğŸ’¬ ì±„íŒ…</span>
        <button class="chat-close" onclick="toggleChat()">Ã—</button>
      </div>
      <div id="chat-box"></div>
      <div class="chat-input-wrapper">
        <input type="text" id="chat-input" placeholder="ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”..." />
        <button onclick="sendChat()">ì „ì†¡</button>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/3.0.4/socket.io.js"></script>
    <script>
      const urlParams = new URLSearchParams(location.search);
      const room = urlParams.get("room");
      const nickname = urlParams.get("name");

      if (!room || !nickname) {
        alert("ì˜ëª»ëœ ì ‘ê·¼ì…ë‹ˆë‹¤.");
        location.href = "/";
      }

      // ì „ì—­ ë³€ìˆ˜ë“¤
      let myStream = null;
      let myPeerConnection = null;
      let remoteStream = null;
      let isScreenSharing = false;
      let screenTrack = null;
      let cameraEnabled = true;
      let micEnabled = true;
      let isInitiator = false; // ë°©ì„ ë§Œë“  ì‚¬ëŒì¸ì§€ í™•ì¸
      
      // ìŠ¤ì™€ì´í”„ ê´€ë ¨ ë³€ìˆ˜
      let currentSlide = 0;
      let totalSlides = 0;
      let startX = 0;
      let currentX = 0;
      let isDragging = false;
      
      // íƒ€ì´ë¨¸ ê´€ë ¨ ë³€ìˆ˜
      let meetingStartTime;
      let meetingDuration = 2 * 60 * 60 * 1000; // 2ì‹œê°„
      let timerInterval;

      const socket = io();
      const chatBox = document.getElementById("chat-box");
      const chatInput = document.getElementById("chat-input");

      // ë””ë²„ê·¸ í•¨ìˆ˜
      function updateDebugInfo() {
        document.getElementById('debug-connection').textContent = 
          myPeerConnection ? myPeerConnection.connectionState : 'ì—†ìŒ';
        document.getElementById('debug-my-stream').textContent = 
          myStream ? `${myStream.getTracks().length}ê°œ íŠ¸ë™` : 'ì—†ìŒ';
        document.getElementById('debug-remote-stream').textContent = 
          remoteStream ? `${remoteStream.getTracks().length}ê°œ íŠ¸ë™` : 'ì—†ìŒ';
        document.getElementById('debug-ice').textContent = 
          myPeerConnection ? myPeerConnection.iceConnectionState : 'ì—†ìŒ';
      }

      // ì†Œì¼“ ì´ë²¤íŠ¸ ì„¤ì •
      socket.emit("join", { roomId: room, nickname });

      socket.on("room-full", () => {
        alert("ì…ì¥ ì¸ì› ì´ˆê³¼");
        location.href = "/";
      });

      socket.on("room-info", (roomInfo) => {
        console.log("ë°© ì •ë³´ ìˆ˜ì‹ :", roomInfo);
        meetingStartTime = roomInfo.createdAt;
        startTimer();
        
        // ì²« ë²ˆì§¸ ì°¸ì—¬ìì¸ì§€ í™•ì¸
        if (roomInfo.participantCount <= 1) {
          isInitiator = true;
          console.log("ë°© ìƒì„±ìë¡œ ì„¤ì •ë¨");
        }
      });

      socket.on("user-joined", async (data) => {
        console.log("ì‚¬ìš©ì ì…ì¥:", data.nickname);
        updateConnectionStatus("connected");
        appendChat("ì‹œìŠ¤í…œ", `${data.nickname}ë‹˜ì´ ì…ì¥í–ˆìŠµë‹ˆë‹¤.`);
        
        // ìƒˆ ì‚¬ìš©ìê°€ ë“¤ì–´ì˜¤ë©´ ê¸°ì¡´ ì‚¬ìš©ìê°€ offerë¥¼ ë³´ëƒ„
        if (isInitiator && myPeerConnection && myStream) {
          console.log("ìƒˆ ì‚¬ìš©ìì—ê²Œ offer ì „ì†¡");
          await createAndSendOffer();
        }
      });

      socket.on("user-left", (data) => {
        console.log("ì‚¬ìš©ì í‡´ì¥:", data.nickname);
        appendChat("ì‹œìŠ¤í…œ", `${data.nickname}ë‹˜ì´ ë°©ì„ ë‚˜ê°”ìŠµë‹ˆë‹¤.`);
        
        // ì›ê²© ìŠ¤íŠ¸ë¦¼ ì •ë¦¬
        if (remoteStream) {
          remoteStream.getTracks().forEach(track => track.stop());
          remoteStream = null;
        }
        
        // ì—°ê²° ì¬ì„¤ì •
        if (myPeerConnection) {
          myPeerConnection.close();
          myPeerConnection = null;
        }
        
        updateVideoSlides();
        updateDebugInfo();
      });

      socket.on("rtc-message", async (message) => {
        try {
          const content = JSON.parse(message);
          console.log("RTC ë©”ì‹œì§€ ìˆ˜ì‹ :", content.event);
          
          // ì—°ê²°ì´ ì—†ìœ¼ë©´ ë¨¼ì € ìƒì„±
          if (!myPeerConnection) {
            await initPeerConnection();
          }
          
          if (content.event === "offer") {
            await handleOffer(content.data);
          } else if (content.event === "answer") {
            await handleAnswer(content.data);
          } else if (content.event === "candidate") {
            await handleCandidate(content.data);
          }
        } catch (error) {
          console.error("RTC ë©”ì‹œì§€ ì²˜ë¦¬ ì˜¤ë¥˜:", error);
        }
      });

      socket.on("chat-message", (data) => {
        const { from, message, timestamp } = JSON.parse(data);
        appendChat(from, message, timestamp);
      });

      // WebRTC í•¨ìˆ˜ë“¤
      async function initializeMedia() {
        try {
          console.log("ë¯¸ë””ì–´ ì´ˆê¸°í™” ì‹œì‘...");
          
          // ì¹´ë©”ë¼ì™€ ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­
          myStream = await navigator.mediaDevices.getUserMedia({
            video: { 
              width: { ideal: 1280 },
              height: { ideal: 720 },
              facingMode: "user"
            },
            audio: true
          });
          
          console.log("ë¯¸ë””ì–´ ìŠ¤íŠ¸ë¦¼ íšë“ ì„±ê³µ:", myStream.getTracks().length, "ê°œ íŠ¸ë™");
          updateVideoSlides();
          updateDebugInfo();
          
          // WebRTC ì—°ê²° ì´ˆê¸°í™”
          await initPeerConnection();
          
          updateConnectionStatus("connected");
          
        } catch (error) {
          console.error("ë¯¸ë””ì–´ ì´ˆê¸°í™” ì˜¤ë¥˜:", error);
          
          // ì¹´ë©”ë¼ ì—†ì´ ì˜¤ë””ì˜¤ë§Œ ì‹œë„
          try {
            myStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            cameraEnabled = false;
            updateCameraButton();
            updateVideoSlides();
            await initPeerConnection();
          } catch (audioError) {
            console.error("ì˜¤ë””ì˜¤ë„ ì‹¤íŒ¨:", audioError);
            updateConnectionStatus("error");
            alert("ì¹´ë©”ë¼ì™€ ë§ˆì´í¬ ì ‘ê·¼ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì„¤ì •ì„ í™•ì¸í•´ì£¼ì„¸ìš”.");
          }
        }
      }

      async function initPeerConnection() {
        console.log("PeerConnection ì´ˆê¸°í™”...");
        
        myPeerConnection = new RTCPeerConnection({
          iceServers: [
            { urls: "stun:stun.l.google.com:19302" },
            { urls: "stun:stun1.l.google.com:19302" },
            { urls: "stun:stun2.l.google.com:19302" }
          ]
        });

        // ICE candidate ì´ë²¤íŠ¸
        myPeerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            console.log("ICE candidate ì „ì†¡:", event.candidate.type);
            sendSignal("candidate", event.candidate);
          } else {
            console.log("ICE candidate ìˆ˜ì§‘ ì™„ë£Œ");
          }
        };

        // ì›ê²© ìŠ¤íŠ¸ë¦¼ ìˆ˜ì‹  ì´ë²¤íŠ¸ - ê°€ì¥ ì¤‘ìš”í•œ ë¶€ë¶„!
        myPeerConnection.ontrack = (event) => {
          console.log("ğŸ¥ ì›ê²© ìŠ¤íŠ¸ë¦¼ ìˆ˜ì‹ !", event.streams[0]);
          console.log("íŠ¸ë™ ì •ë³´:", event.track.kind, event.track.enabled);
          
          remoteStream = event.streams[0];
          
          // ì¦‰ì‹œ UI ì—…ë°ì´íŠ¸
          updateVideoSlides();
          updateDebugInfo();
          
          // ìŠ¤íŠ¸ë¦¼ ìƒíƒœ ë¡œê¹…
          remoteStream.getTracks().forEach(track => {
            console.log(`ì›ê²© íŠ¸ë™: ${track.kind}, í™œì„±: ${track.enabled}, ìƒíƒœ: ${track.readyState}`);
          });
        };

        // ì—°ê²° ìƒíƒœ ë³€ê²½ ì´ë²¤íŠ¸
        myPeerConnection.onconnectionstatechange = () => {
          console.log("ì—°ê²° ìƒíƒœ ë³€ê²½:", myPeerConnection.connectionState);
          updateDebugInfo();
          
          if (myPeerConnection.connectionState === 'connected') {
            updateConnectionStatus("connected");
          } else if (myPeerConnection.connectionState === 'failed') {
            updateConnectionStatus("error");
            console.log("ì—°ê²° ì‹¤íŒ¨ - ì¬ì‹œë„ í•„ìš”");
          }
        };

        // ICE ì—°ê²° ìƒíƒœ ë³€ê²½
        myPeerConnection.oniceconnectionstatechange = () => {
          console.log("ICE ì—°ê²° ìƒíƒœ:", myPeerConnection.iceConnectionState);
          updateDebugInfo();
        };

        // ë¡œì»¬ ìŠ¤íŠ¸ë¦¼ ì¶”ê°€
        if (myStream) {
          console.log("ë¡œì»¬ ìŠ¤íŠ¸ë¦¼ íŠ¸ë™ ì¶”ê°€ ì¤‘...");
          myStream.getTracks().forEach(track => {
            console.log("íŠ¸ë™ ì¶”ê°€:", track.kind, track.enabled);
            myPeerConnection.addTrack(track, myStream);
          });
        }

        updateDebugInfo();
      }

      async function createAndSendOffer() {
        try {
          console.log("Offer ìƒì„± ì¤‘...");
          const offer = await myPeerConnection.createOffer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
          });
          
          await myPeerConnection.setLocalDescription(offer);
          console.log("Offer ìƒì„± ë° ì „ì†¡ ì™„ë£Œ");
          sendSignal("offer", offer);
        } catch (error) {
          console.error("Offer ìƒì„± ì˜¤ë¥˜:", error);
        }
      }

      async function handleOffer(offer) {
        try {
          console.log("Offer ìˆ˜ì‹  ì²˜ë¦¬ ì¤‘...");
          await myPeerConnection.setRemoteDescription(offer);
          
          // ë¡œì»¬ ìŠ¤íŠ¸ë¦¼ì´ ìˆìœ¼ë©´ ì¶”ê°€
          if (myStream) {
            myStream.getTracks().forEach(track => {
              console.log("Answer ìƒì„± ì „ íŠ¸ë™ ì¶”ê°€:", track.kind);
              myPeerConnection.addTrack(track, myStream);
            });
          }
          
          const answer = await myPeerConnection.createAnswer();
          await myPeerConnection.setLocalDescription(answer);
          
          console.log("Answer ìƒì„± ë° ì „ì†¡ ì™„ë£Œ");
          sendSignal("answer", answer);
        } catch (error) {
          console.error("Offer ì²˜ë¦¬ ì˜¤ë¥˜:", error);
        }
      }

      async function handleAnswer(answer) {
        try {
          console.log("Answer ìˆ˜ì‹  ì²˜ë¦¬ ì¤‘...");
          await myPeerConnection.setRemoteDescription(answer);
          console.log("Answer ì²˜ë¦¬ ì™„ë£Œ");
        } catch (error) {
          console.error("Answer ì²˜ë¦¬ ì˜¤ë¥˜:", error);
        }
      }

      async function handleCandidate(candidate) {
        try {
          if (candidate && myPeerConnection.remoteDescription) {
            console.log("ICE candidate ì¶”ê°€:", candidate.type);
            await myPeerConnection.addIceCandidate(candidate);
          } else {
            console.log("ICE candidate ëŒ€ê¸° ì¤‘ (remoteDescription ì—†ìŒ)");
          }
        } catch (error) {
          console.error("ICE candidate ì²˜ë¦¬ ì˜¤ë¥˜:", error);
        }
      }

      function sendSignal(event, data) {
        const message = JSON.stringify({ 
          roomId: room, 
          event, 
          data 
        });
        console.log("ì‹œê·¸ë„ ì „ì†¡:", event);
        socket.emit("rtc-message", message);
      }

      // UI ì—…ë°ì´íŠ¸ í•¨ìˆ˜ë“¤
      function updateVideoSlides() {
        const swipeWrapper = document.getElementById('swipe-wrapper');
        const indicators = document.getElementById('swipe-indicators');
        
        swipeWrapper.innerHTML = '';
        indicators.innerHTML = '';
        
        const slides = [];
        
        // ë‚´ ë¹„ë””ì˜¤ ìŠ¬ë¼ì´ë“œ
        if (myStream) {
          slides.push({
            stream: myStream,
            nickname: `${nickname} (ë‚˜)`,
            isMe: true
          });
        }
        
        // ìƒëŒ€ë°© ë¹„ë””ì˜¤ ìŠ¬ë¼ì´ë“œ
        if (remoteStream) {
          slides.push({
            stream: remoteStream,
            nickname: "ìƒëŒ€ë°©",
            isMe: false
          });
        }
        
        // ë¹ˆ ìŠ¬ë¼ì´ë“œ (ì—°ê²° ëŒ€ê¸° ì¤‘)
        if (slides.length === 0 || !remoteStream) {
          slides.push({
            stream: null,
            nickname: remoteStream ? "ì—°ê²°ë¨" : "ìƒëŒ€ë°© ëŒ€ê¸° ì¤‘",
            isEmpty: true
          });
        }
        
        totalSlides = slides.length;
        
        slides.forEach((slide, index) => {
          const slideElement = document.createElement('div');
          slideElement.className = slide.isEmpty ? 'video-slide empty' : 'video-slide';
          
          if (!slide.isEmpty) {
            const video = document.createElement('video');
            video.autoplay = true;
            video.playsInline = true;
            if (slide.isMe) video.muted = true;
            
            // ìŠ¤íŠ¸ë¦¼ ì—°ê²°
            video.srcObject = slide.stream;
            
            // ë¹„ë””ì˜¤ ë¡œë“œ ì´ë²¤íŠ¸
            video.onloadedmetadata = () => {
              console.log(`ë¹„ë””ì˜¤ ë©”íƒ€ë°ì´í„° ë¡œë“œë¨: ${slide.nickname}`);
              video.play().catch(e => console.error("ë¹„ë””ì˜¤ ì¬ìƒ ì˜¤ë¥˜:", e));
            };
            
            const nicknameLabel = document.createElement('div');
            nicknameLabel.className = 'nickname-label';
            nicknameLabel.textContent = slide.nickname;
            
            slideElement.appendChild(video);
            slideElement.appendChild(nicknameLabel);
          } else {
            const emptyText = document.createElement('div');
            emptyText.textContent = slide.nickname;
            slideElement.appendChild(emptyText);
          }
          
          swipeWrapper.appendChild(slideElement);
          
          // ì¸ë””ì¼€ì´í„° ì¶”ê°€
          const dot = document.createElement('div');
          dot.className = `swipe-dot ${index === currentSlide ? 'active' : ''}`;
          dot.addEventListener('click', () => goToSlide(index));
          indicators.appendChild(dot);
        });
        
        // í˜„ì¬ ìŠ¬ë¼ì´ë“œ ì¡°ì •
        if (currentSlide >= totalSlides) {
          currentSlide = Math.max(0, totalSlides - 1);
        }
        
        goToSlide(currentSlide);
        
        console.log(`ë¹„ë””ì˜¤ ìŠ¬ë¼ì´ë“œ ì—…ë°ì´íŠ¸: ${slides.length}ê°œ`);
      }

      function updateConnectionStatus(status) {
        const statusElement = document.getElementById('connection-status');
        const statusMap = {
          connecting: { text: "ğŸ“¡ ì—°ê²° ì¤‘...", class: "status-connecting" },
          connected: { text: "âœ… ì—°ê²°ë¨", class: "status-connected" },
          error: { text: "âŒ ì—°ê²° ì‹¤íŒ¨", class: "status-error" }
        };
        
        const statusInfo = statusMap[status] || statusMap.connecting;
        statusElement.innerHTML = `<div class="${statusInfo.class}">${statusInfo.text}</div>`;
      }

      // ì»¨íŠ¸ë¡¤ í•¨ìˆ˜ë“¤
      async function toggleCamera() {
        if (!myStream) return;
        
        const videoTrack = myStream.getVideoTracks()[0];
        if (videoTrack) {
          cameraEnabled = !cameraEnabled;
          videoTrack.enabled = cameraEnabled;
          updateCameraButton();
          console.log("ì¹´ë©”ë¼ ìƒíƒœ:", cameraEnabled);
        }
      }

      function updateCameraButton() {
        const button = document.getElementById("toggle-camera");
        if (cameraEnabled) {
          button.textContent = "ğŸ“·";
          button.classList.add("active");
        } else {
          button.textContent = "ğŸ“·";
          button.classList.remove("active");
        }
      }

      async function toggleMic() {
        if (!myStream) return;
        
        const audioTrack = myStream.getAudioTracks()[0];
        if (audioTrack) {
          micEnabled = !micEnabled;
          audioTrack.enabled = micEnabled;
          updateMicButton();
          console.log("ë§ˆì´í¬ ìƒíƒœ:", micEnabled);
        }
      }

      function updateMicButton() {
        const button = document.getElementById("toggle-mic");
        if (micEnabled) {
          button.textContent = "ğŸ¤";
          button.classList.add("active");
        } else {
          button.textContent = "ğŸ¤";
          button.classList.remove("active");
        }
      }

      async function toggleScreenShare() {
        const button = document.getElementById("screen-share-btn");
        
        if (!isScreenSharing) {
          try {
            console.log("í™”ë©´ ê³µìœ  ì‹œì‘...");
            const screenStream = await navigator.mediaDevices.getDisplayMedia({ 
              video: true,
              audio: true 
            });
            
            screenTrack = screenStream.getVideoTracks()[0];
            
            // WebRTC ì—°ê²°ì—ì„œ ë¹„ë””ì˜¤ íŠ¸ë™ êµì²´
            if (myPeerConnection) {
              const sender = myPeerConnection.getSenders().find(s => 
                s.track && s.track.kind === "video"
              );
              if (sender) {
                await sender.replaceTrack(screenTrack);
                console.log("í™”ë©´ ê³µìœ  íŠ¸ë™ êµì²´ ì™„ë£Œ");
              }
            }
            
            // ë¡œì»¬ ìŠ¤íŠ¸ë¦¼ ì—…ë°ì´íŠ¸
            const newStream = new MediaStream([
              screenTrack,
              ...myStream.getAudioTracks()
            ]);
            myStream = newStream;
            
            // í™”ë©´ ê³µìœ  ì¢…ë£Œ ì´ë²¤íŠ¸ ì²˜ë¦¬
            screenTrack.onended = () => {
              console.log("í™”ë©´ ê³µìœ  ì¢…ë£Œë¨");
              stopScreenShare();
            };
            
            isScreenSharing = true;
            button.textContent = "ğŸ–¥ï¸ ê³µìœ ì¤‘";
            button.classList.add("active");
            
            updateVideoSlides();
            
          } catch (error) {
            console.error("í™”ë©´ ê³µìœ  ì˜¤ë¥˜:", error);
            alert("í™”ë©´ ê³µìœ ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: " + error.message);
          }
        } else {
          stopScreenShare();
        }
      }

      async function stopScreenShare() {
        if (!isScreenSharing) return;
        
        try {
          console.log("í™”ë©´ ê³µìœ  ì¤‘ì§€...");
          
          // ì›ë˜ ì¹´ë©”ë¼ë¡œ ë³µì›
          const cameraStream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true
          });
          
          // WebRTC ì—°ê²°ì—ì„œ íŠ¸ë™ êµì²´
          if (myPeerConnection) {
            const sender = myPeerConnection.getSenders().find(s => 
              s.track && s.track.kind === "video"
            );
            if (sender) {
              await sender.replaceTrack(cameraStream.getVideoTracks()[0]);
            }
          }
          
          // í™”ë©´ ê³µìœ  íŠ¸ë™ ì •ë¦¬
          if (screenTrack) {
            screenTrack.stop();
            screenTrack = null;
          }
          
          myStream = cameraStream;
          isScreenSharing = false;
          
          const button = document.getElementById("screen-share-btn");
          button.textContent = "ğŸ–¥ï¸";
          button.classList.remove("active");
          
          updateVideoSlides();
          
        } catch (error) {
          console.error("í™”ë©´ ê³µìœ  ì¤‘ì§€ ì˜¤ë¥˜:", error);
        }
      }

      // ìŠ¤ì™€ì´í”„ ê¸°ëŠ¥
      function initSwipeEvents() {
        const container = document.querySelector('.mobile-container');
        
        // í„°ì¹˜ ì´ë²¤íŠ¸
        container.addEventListener('touchstart', handleTouchStart, { passive: false });
        container.addEventListener('touchmove', handleTouchMove, { passive: false });
        container.addEventListener('touchend', handleTouchEnd, { passive: false });
        
        // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ (ë°ìŠ¤í¬í†± í…ŒìŠ¤íŠ¸ìš©)
        container.addEventListener('mousedown', handleMouseStart);
        container.addEventListener('mousemove', handleMouseMove);
        container.addEventListener('mouseup', handleMouseEnd);
        container.addEventListener('mouseleave', handleMouseEnd);
      }

      function handleTouchStart(e) {
        startX = e.touches[0].clientX;
        isDragging = true;
      }

      function handleTouchMove(e) {
        if (!isDragging) return;
        e.preventDefault();
        
        currentX = e.touches[0].clientX;
        const diffX = currentX - startX;
        const wrapper = document.getElementById('swipe-wrapper');
        
        const translateX = -currentSlide * 100 + (diffX / window.innerWidth) * 100;
        wrapper.style.transform = `translateX(${translateX}%)`;
      }

      function handleTouchEnd(e) {
        if (!isDragging) return;
        isDragging = false;
        
        const diffX = currentX - startX;
        const threshold = window.innerWidth * 0.2;
        
        if (Math.abs(diffX) > threshold) {
          if (diffX > 0 && currentSlide > 0) {
            currentSlide--;
          } else if (diffX < 0 && currentSlide < totalSlides - 1) {
            currentSlide++;
          }
        }
        
        goToSlide(currentSlide);
      }

      function handleMouseStart(e) {
        startX = e.clientX;
        isDragging = true;
        e.preventDefault();
      }

      function handleMouseMove(e) {
        if (!isDragging) return;
        currentX = e.clientX;
        const diffX = currentX - startX;
        const wrapper = document.getElementById('swipe-wrapper');
        const translateX = -currentSlide * 100 + (diffX / window.innerWidth) * 100;
        wrapper.style.transform = `translateX(${translateX}%)`;
      }

      function handleMouseEnd(e) {
        if (!isDragging) return;
        isDragging = false;
        
        const diffX = currentX - startX;
        const threshold = window.innerWidth * 0.2;
        
        if (Math.abs(diffX) > threshold) {
          if (diffX > 0 && currentSlide > 0) {
            currentSlide--;
          } else if (diffX < 0 && currentSlide < totalSlides - 1) {
            currentSlide++;
          }
        }
        
        goToSlide(currentSlide);
      }

      function goToSlide(index) {
        currentSlide = Math.max(0, Math.min(index, totalSlides - 1));
        const wrapper = document.getElementById('swipe-wrapper');
        wrapper.style.transform = `translateX(-${currentSlide * 100}%)`;
        
        // ì¸ë””ì¼€ì´í„° ì—…ë°ì´íŠ¸
        const dots = document.querySelectorAll('.swipe-dot');
        dots.forEach((dot, i) => {
          dot.classList.toggle('active', i === currentSlide);
        });
      }

      // ì±„íŒ… í•¨ìˆ˜ë“¤
      function sendChat() {
        const msg = chatInput.value.trim();
        if (!msg) return;
        
        const now = Date.now();
        socket.emit("chat-message", JSON.stringify({ 
          roomId: room, 
          from: nickname, 
          message: msg, 
          timestamp: now 
        }));
        appendChat(nickname, msg, now);
        chatInput.value = "";
      }

      function appendChat(who, msg, time = null) {
        const p = document.createElement("p");
        const now = time ? new Date(time) : new Date();
        const hhmm = now.toLocaleTimeString("ko-KR", { 
          hour: "2-digit", 
          minute: "2-digit", 
          hour12: false 
        });
        p.textContent = `[${hhmm}] ${who}: ${msg}`;
        chatBox.appendChild(p);
        chatBox.scrollTop = chatBox.scrollHeight;
      }

      function toggleChat() {
        document.getElementById("chat-panel").classList.toggle("open");
      }

      // ë ˆì´ì•„ì›ƒ ìŠ¤í¬ë¦½íŠ¸
      function applyLayoutClass() {
        const videoSlides = document.querySelectorAll('.video-slide');
        const count = videoSlides.length;
        const swipeWrapper = document.querySelector('.swipe-wrapper');
        if (!swipeWrapper) return;
        swipeWrapper.className = swipeWrapper.className
          .split(' ')
          .filter(c => !/^layout-\d+$/.test(c))
          .join(' ');
        swipeWrapper.classList.add('layout-' + count);
      }
      applyLayoutClass();
      
      setInterval(() => {
        applyLayoutClass();
      }, 3000);
      // ì§€í™˜ ë ˆì´ì•„ì›ƒ ìŠ¤í¬ë¦½íŠ¸ ë

      // íƒ€ì´ë¨¸ í•¨ìˆ˜ë“¤
      function startTimer() {
        if (!meetingStartTime) {
          meetingStartTime = Date.now();
        }
        
        updateTimer();
        timerInterval = setInterval(updateTimer, 1000);
      }

      function updateTimer() {
        const currentTime = Date.now();
        const elapsedTime = currentTime - meetingStartTime;
        const remainingTime = meetingDuration - elapsedTime;
        
        const timerDisplay = document.getElementById('timer-display');
        const timerContainer = document.getElementById('timer-container');
        
        if (remainingTime <= 0) {
          timerDisplay.textContent = 'ì‹œê°„ ì¢…ë£Œ';
          timerContainer.classList.add('timer-danger');
          clearInterval(timerInterval);
          
          setTimeout(() => {
            alert('íšŒì˜ ì‹œê°„ì´ ì¢…ë£Œë˜ì–´ ë°©ì—ì„œ ë‚˜ê°‘ë‹ˆë‹¤.');
            leaveRoom();
          }, 3000);
          return;
        }
        
        const hours = Math.floor(remainingTime / (60 * 60 * 1000));
        const minutes = Math.floor((remainingTime % (60 * 60 * 1000)) / (60 * 1000));
        
        timerDisplay.textContent = `íšŒì˜ ì‹œê°„: ${hours}ì‹œê°„ ${minutes.toString().padStart(2, '0')}ë¶„`;
        
        if (remainingTime <= 30 * 60 * 1000) {
          timerContainer.classList.add('timer-warning');
        }
        
        if (remainingTime <= 5 * 60 * 1000) {
          timerContainer.classList.remove('timer-warning');
          timerContainer.classList.add('timer-danger');
        }
      }

      function leaveRoom() {
        if (timerInterval) {
          clearInterval(timerInterval);
        }
        
        if (myStream) {
          myStream.getTracks().forEach(track => track.stop());
        }
        
        if (myPeerConnection) {
          myPeerConnection.close();
        }
        
        socket.disconnect();
        location.href = "/";
      }

      // ì´ˆê¸°í™”
      async function initialize() {
        console.log("ì•± ì´ˆê¸°í™” ì‹œì‘...");
        
        document.getElementById("title").textContent = `ë°©: ${room} | ${nickname}`;
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        chatInput.addEventListener("keyup", (e) => {
          if (e.key === "Enter") sendChat();
        });
        
        // ìŠ¤ì™€ì´í”„ ì´ë²¤íŠ¸ ì´ˆê¸°í™”
        initSwipeEvents();
        
        // ë¯¸ë””ì–´ ì´ˆê¸°í™”
        await initializeMedia();
        
        // ë””ë²„ê·¸ ì •ë³´ ì£¼ê¸°ì  ì—…ë°ì´íŠ¸
        setInterval(updateDebugInfo, 2000);
        
        console.log("ì´ˆê¸°í™” ì™„ë£Œ");
      }

      // ì•± ì‹œì‘
      initialize().catch(error => {
        console.error("ì´ˆê¸°í™” ì˜¤ë¥˜:", error);
        updateConnectionStatus("error");
      });
    </script>
  </body>
</html>
